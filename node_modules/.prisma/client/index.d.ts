
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserTopRankings
 * 
 */
export type UserTopRankings = $Result.DefaultSelection<Prisma.$UserTopRankingsPayload>
/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model PlayerPool
 * 
 */
export type PlayerPool = $Result.DefaultSelection<Prisma.$PlayerPoolPayload>
/**
 * Model Squard
 * 
 */
export type Squard = $Result.DefaultSelection<Prisma.$SquardPayload>
/**
 * Model Matching
 * 
 */
export type Matching = $Result.DefaultSelection<Prisma.$MatchingPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userTopRankings`: Exposes CRUD operations for the **UserTopRankings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTopRankings
    * const userTopRankings = await prisma.userTopRankings.findMany()
    * ```
    */
  get userTopRankings(): Prisma.UserTopRankingsDelegate<ExtArgs>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs>;

  /**
   * `prisma.playerPool`: Exposes CRUD operations for the **PlayerPool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerPools
    * const playerPools = await prisma.playerPool.findMany()
    * ```
    */
  get playerPool(): Prisma.PlayerPoolDelegate<ExtArgs>;

  /**
   * `prisma.squard`: Exposes CRUD operations for the **Squard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Squards
    * const squards = await prisma.squard.findMany()
    * ```
    */
  get squard(): Prisma.SquardDelegate<ExtArgs>;

  /**
   * `prisma.matching`: Exposes CRUD operations for the **Matching** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matchings
    * const matchings = await prisma.matching.findMany()
    * ```
    */
  get matching(): Prisma.MatchingDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.15.0
   * Query Engine version: 12e25d8d06f6ea5a0252864dd9a03b1bb51f3022
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserTopRankings: 'UserTopRankings',
    Player: 'Player',
    PlayerPool: 'PlayerPool',
    Squard: 'Squard',
    Matching: 'Matching'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'userTopRankings' | 'player' | 'playerPool' | 'squard' | 'matching'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserTopRankings: {
        payload: Prisma.$UserTopRankingsPayload<ExtArgs>
        fields: Prisma.UserTopRankingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTopRankingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTopRankingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTopRankingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTopRankingsPayload>
          }
          findFirst: {
            args: Prisma.UserTopRankingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTopRankingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTopRankingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTopRankingsPayload>
          }
          findMany: {
            args: Prisma.UserTopRankingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTopRankingsPayload>[]
          }
          create: {
            args: Prisma.UserTopRankingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTopRankingsPayload>
          }
          createMany: {
            args: Prisma.UserTopRankingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserTopRankingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTopRankingsPayload>
          }
          update: {
            args: Prisma.UserTopRankingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTopRankingsPayload>
          }
          deleteMany: {
            args: Prisma.UserTopRankingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserTopRankingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserTopRankingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTopRankingsPayload>
          }
          aggregate: {
            args: Prisma.UserTopRankingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserTopRankings>
          }
          groupBy: {
            args: Prisma.UserTopRankingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserTopRankingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTopRankingsCountArgs<ExtArgs>,
            result: $Utils.Optional<UserTopRankingsCountAggregateOutputType> | number
          }
        }
      }
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>,
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      PlayerPool: {
        payload: Prisma.$PlayerPoolPayload<ExtArgs>
        fields: Prisma.PlayerPoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerPoolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerPoolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPoolPayload>
          }
          findFirst: {
            args: Prisma.PlayerPoolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerPoolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPoolPayload>
          }
          findMany: {
            args: Prisma.PlayerPoolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPoolPayload>[]
          }
          create: {
            args: Prisma.PlayerPoolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPoolPayload>
          }
          createMany: {
            args: Prisma.PlayerPoolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PlayerPoolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPoolPayload>
          }
          update: {
            args: Prisma.PlayerPoolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPoolPayload>
          }
          deleteMany: {
            args: Prisma.PlayerPoolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerPoolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PlayerPoolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlayerPoolPayload>
          }
          aggregate: {
            args: Prisma.PlayerPoolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlayerPool>
          }
          groupBy: {
            args: Prisma.PlayerPoolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlayerPoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerPoolCountArgs<ExtArgs>,
            result: $Utils.Optional<PlayerPoolCountAggregateOutputType> | number
          }
        }
      }
      Squard: {
        payload: Prisma.$SquardPayload<ExtArgs>
        fields: Prisma.SquardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SquardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SquardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SquardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SquardPayload>
          }
          findFirst: {
            args: Prisma.SquardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SquardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SquardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SquardPayload>
          }
          findMany: {
            args: Prisma.SquardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SquardPayload>[]
          }
          create: {
            args: Prisma.SquardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SquardPayload>
          }
          createMany: {
            args: Prisma.SquardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SquardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SquardPayload>
          }
          update: {
            args: Prisma.SquardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SquardPayload>
          }
          deleteMany: {
            args: Prisma.SquardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SquardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SquardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SquardPayload>
          }
          aggregate: {
            args: Prisma.SquardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSquard>
          }
          groupBy: {
            args: Prisma.SquardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SquardGroupByOutputType>[]
          }
          count: {
            args: Prisma.SquardCountArgs<ExtArgs>,
            result: $Utils.Optional<SquardCountAggregateOutputType> | number
          }
        }
      }
      Matching: {
        payload: Prisma.$MatchingPayload<ExtArgs>
        fields: Prisma.MatchingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchingPayload>
          }
          findFirst: {
            args: Prisma.MatchingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchingPayload>
          }
          findMany: {
            args: Prisma.MatchingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchingPayload>[]
          }
          create: {
            args: Prisma.MatchingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchingPayload>
          }
          createMany: {
            args: Prisma.MatchingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MatchingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchingPayload>
          }
          update: {
            args: Prisma.MatchingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchingPayload>
          }
          deleteMany: {
            args: Prisma.MatchingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MatchingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MatchingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchingPayload>
          }
          aggregate: {
            args: Prisma.MatchingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMatching>
          }
          groupBy: {
            args: Prisma.MatchingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MatchingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchingCountArgs<ExtArgs>,
            result: $Utils.Optional<MatchingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    playerPool: number
    squard: number
    home: number
    away: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerPool?: boolean | UserCountOutputTypeCountPlayerPoolArgs
    squard?: boolean | UserCountOutputTypeCountSquardArgs
    home?: boolean | UserCountOutputTypeCountHomeArgs
    away?: boolean | UserCountOutputTypeCountAwayArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlayerPoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerPoolWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSquardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SquardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAwayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchingWhereInput
  }


  /**
   * Count Type PlayerCountOutputType
   */

  export type PlayerCountOutputType = {
    playerPool: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerPool?: boolean | PlayerCountOutputTypeCountPlayerPoolArgs
  }

  // Custom InputTypes
  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPlayerPoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerPoolWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    cash: number | null
    mmr: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    cash: number | null
    mmr: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    accountName: string | null
    password: string | null
    createdAt: Date | null
    cash: number | null
    mmr: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    accountName: string | null
    password: string | null
    createdAt: Date | null
    cash: number | null
    mmr: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    accountName: number
    password: number
    createdAt: number
    cash: number
    mmr: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    cash?: true
    mmr?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    cash?: true
    mmr?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    accountName?: true
    password?: true
    createdAt?: true
    cash?: true
    mmr?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    accountName?: true
    password?: true
    createdAt?: true
    cash?: true
    mmr?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    accountName?: true
    password?: true
    createdAt?: true
    cash?: true
    mmr?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    accountName: string
    password: string
    createdAt: Date
    cash: number
    mmr: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountName?: boolean
    password?: boolean
    createdAt?: boolean
    cash?: boolean
    mmr?: boolean
    playerPool?: boolean | User$playerPoolArgs<ExtArgs>
    squard?: boolean | User$squardArgs<ExtArgs>
    home?: boolean | User$homeArgs<ExtArgs>
    away?: boolean | User$awayArgs<ExtArgs>
    rank?: boolean | User$rankArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    accountName?: boolean
    password?: boolean
    createdAt?: boolean
    cash?: boolean
    mmr?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerPool?: boolean | User$playerPoolArgs<ExtArgs>
    squard?: boolean | User$squardArgs<ExtArgs>
    home?: boolean | User$homeArgs<ExtArgs>
    away?: boolean | User$awayArgs<ExtArgs>
    rank?: boolean | User$rankArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      playerPool: Prisma.$PlayerPoolPayload<ExtArgs>[]
      squard: Prisma.$SquardPayload<ExtArgs>[]
      home: Prisma.$MatchingPayload<ExtArgs>[]
      away: Prisma.$MatchingPayload<ExtArgs>[]
      rank: Prisma.$UserTopRankingsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accountName: string
      password: string
      createdAt: Date
      cash: number
      mmr: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    playerPool<T extends User$playerPoolArgs<ExtArgs> = {}>(args?: Subset<T, User$playerPoolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'findMany'> | Null>;

    squard<T extends User$squardArgs<ExtArgs> = {}>(args?: Subset<T, User$squardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'findMany'> | Null>;

    home<T extends User$homeArgs<ExtArgs> = {}>(args?: Subset<T, User$homeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'findMany'> | Null>;

    away<T extends User$awayArgs<ExtArgs> = {}>(args?: Subset<T, User$awayArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'findMany'> | Null>;

    rank<T extends User$rankArgs<ExtArgs> = {}>(args?: Subset<T, User$rankArgs<ExtArgs>>): Prisma__UserTopRankingsClient<$Result.GetResult<Prisma.$UserTopRankingsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly accountName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly cash: FieldRef<"User", 'Int'>
    readonly mmr: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.playerPool
   */
  export type User$playerPoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    where?: PlayerPoolWhereInput
    orderBy?: PlayerPoolOrderByWithRelationInput | PlayerPoolOrderByWithRelationInput[]
    cursor?: PlayerPoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerPoolScalarFieldEnum | PlayerPoolScalarFieldEnum[]
  }

  /**
   * User.squard
   */
  export type User$squardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    where?: SquardWhereInput
    orderBy?: SquardOrderByWithRelationInput | SquardOrderByWithRelationInput[]
    cursor?: SquardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SquardScalarFieldEnum | SquardScalarFieldEnum[]
  }

  /**
   * User.home
   */
  export type User$homeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    where?: MatchingWhereInput
    orderBy?: MatchingOrderByWithRelationInput | MatchingOrderByWithRelationInput[]
    cursor?: MatchingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchingScalarFieldEnum | MatchingScalarFieldEnum[]
  }

  /**
   * User.away
   */
  export type User$awayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    where?: MatchingWhereInput
    orderBy?: MatchingOrderByWithRelationInput | MatchingOrderByWithRelationInput[]
    cursor?: MatchingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchingScalarFieldEnum | MatchingScalarFieldEnum[]
  }

  /**
   * User.rank
   */
  export type User$rankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
    where?: UserTopRankingsWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserTopRankings
   */

  export type AggregateUserTopRankings = {
    _count: UserTopRankingsCountAggregateOutputType | null
    _avg: UserTopRankingsAvgAggregateOutputType | null
    _sum: UserTopRankingsSumAggregateOutputType | null
    _min: UserTopRankingsMinAggregateOutputType | null
    _max: UserTopRankingsMaxAggregateOutputType | null
  }

  export type UserTopRankingsAvgAggregateOutputType = {
    userId: number | null
    rank: number | null
    mmr: number | null
  }

  export type UserTopRankingsSumAggregateOutputType = {
    userId: number | null
    rank: number | null
    mmr: number | null
  }

  export type UserTopRankingsMinAggregateOutputType = {
    userId: number | null
    rank: number | null
    mmr: number | null
  }

  export type UserTopRankingsMaxAggregateOutputType = {
    userId: number | null
    rank: number | null
    mmr: number | null
  }

  export type UserTopRankingsCountAggregateOutputType = {
    userId: number
    rank: number
    mmr: number
    _all: number
  }


  export type UserTopRankingsAvgAggregateInputType = {
    userId?: true
    rank?: true
    mmr?: true
  }

  export type UserTopRankingsSumAggregateInputType = {
    userId?: true
    rank?: true
    mmr?: true
  }

  export type UserTopRankingsMinAggregateInputType = {
    userId?: true
    rank?: true
    mmr?: true
  }

  export type UserTopRankingsMaxAggregateInputType = {
    userId?: true
    rank?: true
    mmr?: true
  }

  export type UserTopRankingsCountAggregateInputType = {
    userId?: true
    rank?: true
    mmr?: true
    _all?: true
  }

  export type UserTopRankingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTopRankings to aggregate.
     */
    where?: UserTopRankingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTopRankings to fetch.
     */
    orderBy?: UserTopRankingsOrderByWithRelationInput | UserTopRankingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTopRankingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTopRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTopRankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTopRankings
    **/
    _count?: true | UserTopRankingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTopRankingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTopRankingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTopRankingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTopRankingsMaxAggregateInputType
  }

  export type GetUserTopRankingsAggregateType<T extends UserTopRankingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTopRankings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTopRankings[P]>
      : GetScalarType<T[P], AggregateUserTopRankings[P]>
  }




  export type UserTopRankingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTopRankingsWhereInput
    orderBy?: UserTopRankingsOrderByWithAggregationInput | UserTopRankingsOrderByWithAggregationInput[]
    by: UserTopRankingsScalarFieldEnum[] | UserTopRankingsScalarFieldEnum
    having?: UserTopRankingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTopRankingsCountAggregateInputType | true
    _avg?: UserTopRankingsAvgAggregateInputType
    _sum?: UserTopRankingsSumAggregateInputType
    _min?: UserTopRankingsMinAggregateInputType
    _max?: UserTopRankingsMaxAggregateInputType
  }

  export type UserTopRankingsGroupByOutputType = {
    userId: number
    rank: number
    mmr: number
    _count: UserTopRankingsCountAggregateOutputType | null
    _avg: UserTopRankingsAvgAggregateOutputType | null
    _sum: UserTopRankingsSumAggregateOutputType | null
    _min: UserTopRankingsMinAggregateOutputType | null
    _max: UserTopRankingsMaxAggregateOutputType | null
  }

  type GetUserTopRankingsGroupByPayload<T extends UserTopRankingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTopRankingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTopRankingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTopRankingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserTopRankingsGroupByOutputType[P]>
        }
      >
    >


  export type UserTopRankingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    rank?: boolean
    mmr?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTopRankings"]>


  export type UserTopRankingsSelectScalar = {
    userId?: boolean
    rank?: boolean
    mmr?: boolean
  }

  export type UserTopRankingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserTopRankingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTopRankings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      rank: number
      mmr: number
    }, ExtArgs["result"]["userTopRankings"]>
    composites: {}
  }

  type UserTopRankingsGetPayload<S extends boolean | null | undefined | UserTopRankingsDefaultArgs> = $Result.GetResult<Prisma.$UserTopRankingsPayload, S>

  type UserTopRankingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserTopRankingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserTopRankingsCountAggregateInputType | true
    }

  export interface UserTopRankingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTopRankings'], meta: { name: 'UserTopRankings' } }
    /**
     * Find zero or one UserTopRankings that matches the filter.
     * @param {UserTopRankingsFindUniqueArgs} args - Arguments to find a UserTopRankings
     * @example
     * // Get one UserTopRankings
     * const userTopRankings = await prisma.userTopRankings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserTopRankingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserTopRankingsFindUniqueArgs<ExtArgs>>
    ): Prisma__UserTopRankingsClient<$Result.GetResult<Prisma.$UserTopRankingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserTopRankings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserTopRankingsFindUniqueOrThrowArgs} args - Arguments to find a UserTopRankings
     * @example
     * // Get one UserTopRankings
     * const userTopRankings = await prisma.userTopRankings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserTopRankingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTopRankingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserTopRankingsClient<$Result.GetResult<Prisma.$UserTopRankingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserTopRankings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopRankingsFindFirstArgs} args - Arguments to find a UserTopRankings
     * @example
     * // Get one UserTopRankings
     * const userTopRankings = await prisma.userTopRankings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserTopRankingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTopRankingsFindFirstArgs<ExtArgs>>
    ): Prisma__UserTopRankingsClient<$Result.GetResult<Prisma.$UserTopRankingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserTopRankings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopRankingsFindFirstOrThrowArgs} args - Arguments to find a UserTopRankings
     * @example
     * // Get one UserTopRankings
     * const userTopRankings = await prisma.userTopRankings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserTopRankingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTopRankingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserTopRankingsClient<$Result.GetResult<Prisma.$UserTopRankingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserTopRankings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopRankingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTopRankings
     * const userTopRankings = await prisma.userTopRankings.findMany()
     * 
     * // Get first 10 UserTopRankings
     * const userTopRankings = await prisma.userTopRankings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userTopRankingsWithUserIdOnly = await prisma.userTopRankings.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserTopRankingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTopRankingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTopRankingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserTopRankings.
     * @param {UserTopRankingsCreateArgs} args - Arguments to create a UserTopRankings.
     * @example
     * // Create one UserTopRankings
     * const UserTopRankings = await prisma.userTopRankings.create({
     *   data: {
     *     // ... data to create a UserTopRankings
     *   }
     * })
     * 
    **/
    create<T extends UserTopRankingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserTopRankingsCreateArgs<ExtArgs>>
    ): Prisma__UserTopRankingsClient<$Result.GetResult<Prisma.$UserTopRankingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserTopRankings.
     * @param {UserTopRankingsCreateManyArgs} args - Arguments to create many UserTopRankings.
     * @example
     * // Create many UserTopRankings
     * const userTopRankings = await prisma.userTopRankings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserTopRankingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTopRankingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserTopRankings.
     * @param {UserTopRankingsDeleteArgs} args - Arguments to delete one UserTopRankings.
     * @example
     * // Delete one UserTopRankings
     * const UserTopRankings = await prisma.userTopRankings.delete({
     *   where: {
     *     // ... filter to delete one UserTopRankings
     *   }
     * })
     * 
    **/
    delete<T extends UserTopRankingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserTopRankingsDeleteArgs<ExtArgs>>
    ): Prisma__UserTopRankingsClient<$Result.GetResult<Prisma.$UserTopRankingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserTopRankings.
     * @param {UserTopRankingsUpdateArgs} args - Arguments to update one UserTopRankings.
     * @example
     * // Update one UserTopRankings
     * const userTopRankings = await prisma.userTopRankings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserTopRankingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserTopRankingsUpdateArgs<ExtArgs>>
    ): Prisma__UserTopRankingsClient<$Result.GetResult<Prisma.$UserTopRankingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserTopRankings.
     * @param {UserTopRankingsDeleteManyArgs} args - Arguments to filter UserTopRankings to delete.
     * @example
     * // Delete a few UserTopRankings
     * const { count } = await prisma.userTopRankings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserTopRankingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTopRankingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTopRankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopRankingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTopRankings
     * const userTopRankings = await prisma.userTopRankings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserTopRankingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserTopRankingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTopRankings.
     * @param {UserTopRankingsUpsertArgs} args - Arguments to update or create a UserTopRankings.
     * @example
     * // Update or create a UserTopRankings
     * const userTopRankings = await prisma.userTopRankings.upsert({
     *   create: {
     *     // ... data to create a UserTopRankings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTopRankings we want to update
     *   }
     * })
    **/
    upsert<T extends UserTopRankingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserTopRankingsUpsertArgs<ExtArgs>>
    ): Prisma__UserTopRankingsClient<$Result.GetResult<Prisma.$UserTopRankingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserTopRankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopRankingsCountArgs} args - Arguments to filter UserTopRankings to count.
     * @example
     * // Count the number of UserTopRankings
     * const count = await prisma.userTopRankings.count({
     *   where: {
     *     // ... the filter for the UserTopRankings we want to count
     *   }
     * })
    **/
    count<T extends UserTopRankingsCountArgs>(
      args?: Subset<T, UserTopRankingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTopRankingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTopRankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopRankingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTopRankingsAggregateArgs>(args: Subset<T, UserTopRankingsAggregateArgs>): Prisma.PrismaPromise<GetUserTopRankingsAggregateType<T>>

    /**
     * Group by UserTopRankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopRankingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTopRankingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTopRankingsGroupByArgs['orderBy'] }
        : { orderBy?: UserTopRankingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTopRankingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTopRankingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTopRankings model
   */
  readonly fields: UserTopRankingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTopRankings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTopRankingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserTopRankings model
   */ 
  interface UserTopRankingsFieldRefs {
    readonly userId: FieldRef<"UserTopRankings", 'Int'>
    readonly rank: FieldRef<"UserTopRankings", 'Int'>
    readonly mmr: FieldRef<"UserTopRankings", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserTopRankings findUnique
   */
  export type UserTopRankingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
    /**
     * Filter, which UserTopRankings to fetch.
     */
    where: UserTopRankingsWhereUniqueInput
  }

  /**
   * UserTopRankings findUniqueOrThrow
   */
  export type UserTopRankingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
    /**
     * Filter, which UserTopRankings to fetch.
     */
    where: UserTopRankingsWhereUniqueInput
  }

  /**
   * UserTopRankings findFirst
   */
  export type UserTopRankingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
    /**
     * Filter, which UserTopRankings to fetch.
     */
    where?: UserTopRankingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTopRankings to fetch.
     */
    orderBy?: UserTopRankingsOrderByWithRelationInput | UserTopRankingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTopRankings.
     */
    cursor?: UserTopRankingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTopRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTopRankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTopRankings.
     */
    distinct?: UserTopRankingsScalarFieldEnum | UserTopRankingsScalarFieldEnum[]
  }

  /**
   * UserTopRankings findFirstOrThrow
   */
  export type UserTopRankingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
    /**
     * Filter, which UserTopRankings to fetch.
     */
    where?: UserTopRankingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTopRankings to fetch.
     */
    orderBy?: UserTopRankingsOrderByWithRelationInput | UserTopRankingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTopRankings.
     */
    cursor?: UserTopRankingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTopRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTopRankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTopRankings.
     */
    distinct?: UserTopRankingsScalarFieldEnum | UserTopRankingsScalarFieldEnum[]
  }

  /**
   * UserTopRankings findMany
   */
  export type UserTopRankingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
    /**
     * Filter, which UserTopRankings to fetch.
     */
    where?: UserTopRankingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTopRankings to fetch.
     */
    orderBy?: UserTopRankingsOrderByWithRelationInput | UserTopRankingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTopRankings.
     */
    cursor?: UserTopRankingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTopRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTopRankings.
     */
    skip?: number
    distinct?: UserTopRankingsScalarFieldEnum | UserTopRankingsScalarFieldEnum[]
  }

  /**
   * UserTopRankings create
   */
  export type UserTopRankingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTopRankings.
     */
    data: XOR<UserTopRankingsCreateInput, UserTopRankingsUncheckedCreateInput>
  }

  /**
   * UserTopRankings createMany
   */
  export type UserTopRankingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTopRankings.
     */
    data: UserTopRankingsCreateManyInput | UserTopRankingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTopRankings update
   */
  export type UserTopRankingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTopRankings.
     */
    data: XOR<UserTopRankingsUpdateInput, UserTopRankingsUncheckedUpdateInput>
    /**
     * Choose, which UserTopRankings to update.
     */
    where: UserTopRankingsWhereUniqueInput
  }

  /**
   * UserTopRankings updateMany
   */
  export type UserTopRankingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTopRankings.
     */
    data: XOR<UserTopRankingsUpdateManyMutationInput, UserTopRankingsUncheckedUpdateManyInput>
    /**
     * Filter which UserTopRankings to update
     */
    where?: UserTopRankingsWhereInput
  }

  /**
   * UserTopRankings upsert
   */
  export type UserTopRankingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTopRankings to update in case it exists.
     */
    where: UserTopRankingsWhereUniqueInput
    /**
     * In case the UserTopRankings found by the `where` argument doesn't exist, create a new UserTopRankings with this data.
     */
    create: XOR<UserTopRankingsCreateInput, UserTopRankingsUncheckedCreateInput>
    /**
     * In case the UserTopRankings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTopRankingsUpdateInput, UserTopRankingsUncheckedUpdateInput>
  }

  /**
   * UserTopRankings delete
   */
  export type UserTopRankingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
    /**
     * Filter which UserTopRankings to delete.
     */
    where: UserTopRankingsWhereUniqueInput
  }

  /**
   * UserTopRankings deleteMany
   */
  export type UserTopRankingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTopRankings to delete
     */
    where?: UserTopRankingsWhereInput
  }

  /**
   * UserTopRankings without action
   */
  export type UserTopRankingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopRankings
     */
    select?: UserTopRankingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopRankingsInclude<ExtArgs> | null
  }


  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    id: number | null
    speed: number | null
    passing: number | null
    dribbling: number | null
    heading: number | null
    shooting: number | null
    tackling: number | null
    marking: number | null
    strength: number | null
    weight: number | null
  }

  export type PlayerSumAggregateOutputType = {
    id: number | null
    speed: number | null
    passing: number | null
    dribbling: number | null
    heading: number | null
    shooting: number | null
    tackling: number | null
    marking: number | null
    strength: number | null
    weight: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: number | null
    name: string | null
    speed: number | null
    passing: number | null
    dribbling: number | null
    heading: number | null
    shooting: number | null
    tackling: number | null
    marking: number | null
    strength: number | null
    weight: number | null
    nationality: string | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    speed: number | null
    passing: number | null
    dribbling: number | null
    heading: number | null
    shooting: number | null
    tackling: number | null
    marking: number | null
    strength: number | null
    weight: number | null
    nationality: string | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    name: number
    speed: number
    passing: number
    dribbling: number
    heading: number
    shooting: number
    tackling: number
    marking: number
    strength: number
    weight: number
    nationality: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    id?: true
    speed?: true
    passing?: true
    dribbling?: true
    heading?: true
    shooting?: true
    tackling?: true
    marking?: true
    strength?: true
    weight?: true
  }

  export type PlayerSumAggregateInputType = {
    id?: true
    speed?: true
    passing?: true
    dribbling?: true
    heading?: true
    shooting?: true
    tackling?: true
    marking?: true
    strength?: true
    weight?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    name?: true
    speed?: true
    passing?: true
    dribbling?: true
    heading?: true
    shooting?: true
    tackling?: true
    marking?: true
    strength?: true
    weight?: true
    nationality?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    name?: true
    speed?: true
    passing?: true
    dribbling?: true
    heading?: true
    shooting?: true
    tackling?: true
    marking?: true
    strength?: true
    weight?: true
    nationality?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    name?: true
    speed?: true
    passing?: true
    dribbling?: true
    heading?: true
    shooting?: true
    tackling?: true
    marking?: true
    strength?: true
    weight?: true
    nationality?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: number
    name: string
    speed: number
    passing: number
    dribbling: number
    heading: number
    shooting: number
    tackling: number
    marking: number
    strength: number
    weight: number
    nationality: string
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    speed?: boolean
    passing?: boolean
    dribbling?: boolean
    heading?: boolean
    shooting?: boolean
    tackling?: boolean
    marking?: boolean
    strength?: boolean
    weight?: boolean
    nationality?: boolean
    playerPool?: boolean | Player$playerPoolArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>


  export type PlayerSelectScalar = {
    id?: boolean
    name?: boolean
    speed?: boolean
    passing?: boolean
    dribbling?: boolean
    heading?: boolean
    shooting?: boolean
    tackling?: boolean
    marking?: boolean
    strength?: boolean
    weight?: boolean
    nationality?: boolean
  }

  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerPool?: boolean | Player$playerPoolArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      playerPool: Prisma.$PlayerPoolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      speed: number
      passing: number
      dribbling: number
      heading: number
      shooting: number
      tackling: number
      marking: number
      strength: number
      weight: number
      nationality: string
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
    **/
    create<T extends PlayerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PlayerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
    **/
    delete<T extends PlayerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    playerPool<T extends Player$playerPoolArgs<ExtArgs> = {}>(args?: Subset<T, Player$playerPoolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Player model
   */ 
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'Int'>
    readonly name: FieldRef<"Player", 'String'>
    readonly speed: FieldRef<"Player", 'Int'>
    readonly passing: FieldRef<"Player", 'Int'>
    readonly dribbling: FieldRef<"Player", 'Int'>
    readonly heading: FieldRef<"Player", 'Int'>
    readonly shooting: FieldRef<"Player", 'Int'>
    readonly tackling: FieldRef<"Player", 'Int'>
    readonly marking: FieldRef<"Player", 'Int'>
    readonly strength: FieldRef<"Player", 'Int'>
    readonly weight: FieldRef<"Player", 'Int'>
    readonly nationality: FieldRef<"Player", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
  }

  /**
   * Player.playerPool
   */
  export type Player$playerPoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    where?: PlayerPoolWhereInput
    orderBy?: PlayerPoolOrderByWithRelationInput | PlayerPoolOrderByWithRelationInput[]
    cursor?: PlayerPoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerPoolScalarFieldEnum | PlayerPoolScalarFieldEnum[]
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model PlayerPool
   */

  export type AggregatePlayerPool = {
    _count: PlayerPoolCountAggregateOutputType | null
    _avg: PlayerPoolAvgAggregateOutputType | null
    _sum: PlayerPoolSumAggregateOutputType | null
    _min: PlayerPoolMinAggregateOutputType | null
    _max: PlayerPoolMaxAggregateOutputType | null
  }

  export type PlayerPoolAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    playerId: number | null
    playerLevel: number | null
    count: number | null
    stamina: number | null
  }

  export type PlayerPoolSumAggregateOutputType = {
    id: number | null
    userId: number | null
    playerId: number | null
    playerLevel: number | null
    count: number | null
    stamina: number | null
  }

  export type PlayerPoolMinAggregateOutputType = {
    id: number | null
    userId: number | null
    playerId: number | null
    createdAt: Date | null
    playerLevel: number | null
    playerName: string | null
    count: number | null
    sidelined: boolean | null
    stamina: number | null
  }

  export type PlayerPoolMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    playerId: number | null
    createdAt: Date | null
    playerLevel: number | null
    playerName: string | null
    count: number | null
    sidelined: boolean | null
    stamina: number | null
  }

  export type PlayerPoolCountAggregateOutputType = {
    id: number
    userId: number
    playerId: number
    createdAt: number
    playerLevel: number
    playerName: number
    count: number
    sidelined: number
    stamina: number
    _all: number
  }


  export type PlayerPoolAvgAggregateInputType = {
    id?: true
    userId?: true
    playerId?: true
    playerLevel?: true
    count?: true
    stamina?: true
  }

  export type PlayerPoolSumAggregateInputType = {
    id?: true
    userId?: true
    playerId?: true
    playerLevel?: true
    count?: true
    stamina?: true
  }

  export type PlayerPoolMinAggregateInputType = {
    id?: true
    userId?: true
    playerId?: true
    createdAt?: true
    playerLevel?: true
    playerName?: true
    count?: true
    sidelined?: true
    stamina?: true
  }

  export type PlayerPoolMaxAggregateInputType = {
    id?: true
    userId?: true
    playerId?: true
    createdAt?: true
    playerLevel?: true
    playerName?: true
    count?: true
    sidelined?: true
    stamina?: true
  }

  export type PlayerPoolCountAggregateInputType = {
    id?: true
    userId?: true
    playerId?: true
    createdAt?: true
    playerLevel?: true
    playerName?: true
    count?: true
    sidelined?: true
    stamina?: true
    _all?: true
  }

  export type PlayerPoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerPool to aggregate.
     */
    where?: PlayerPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPools to fetch.
     */
    orderBy?: PlayerPoolOrderByWithRelationInput | PlayerPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerPools
    **/
    _count?: true | PlayerPoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerPoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerPoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerPoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerPoolMaxAggregateInputType
  }

  export type GetPlayerPoolAggregateType<T extends PlayerPoolAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerPool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerPool[P]>
      : GetScalarType<T[P], AggregatePlayerPool[P]>
  }




  export type PlayerPoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerPoolWhereInput
    orderBy?: PlayerPoolOrderByWithAggregationInput | PlayerPoolOrderByWithAggregationInput[]
    by: PlayerPoolScalarFieldEnum[] | PlayerPoolScalarFieldEnum
    having?: PlayerPoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerPoolCountAggregateInputType | true
    _avg?: PlayerPoolAvgAggregateInputType
    _sum?: PlayerPoolSumAggregateInputType
    _min?: PlayerPoolMinAggregateInputType
    _max?: PlayerPoolMaxAggregateInputType
  }

  export type PlayerPoolGroupByOutputType = {
    id: number
    userId: number
    playerId: number
    createdAt: Date
    playerLevel: number
    playerName: string
    count: number
    sidelined: boolean
    stamina: number
    _count: PlayerPoolCountAggregateOutputType | null
    _avg: PlayerPoolAvgAggregateOutputType | null
    _sum: PlayerPoolSumAggregateOutputType | null
    _min: PlayerPoolMinAggregateOutputType | null
    _max: PlayerPoolMaxAggregateOutputType | null
  }

  type GetPlayerPoolGroupByPayload<T extends PlayerPoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerPoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerPoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerPoolGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerPoolGroupByOutputType[P]>
        }
      >
    >


  export type PlayerPoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    playerId?: boolean
    createdAt?: boolean
    playerLevel?: boolean
    playerName?: boolean
    count?: boolean
    sidelined?: boolean
    stamina?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    playerIndex?: boolean | PlayerDefaultArgs<ExtArgs>
    squard?: boolean | PlayerPool$squardArgs<ExtArgs>
  }, ExtArgs["result"]["playerPool"]>


  export type PlayerPoolSelectScalar = {
    id?: boolean
    userId?: boolean
    playerId?: boolean
    createdAt?: boolean
    playerLevel?: boolean
    playerName?: boolean
    count?: boolean
    sidelined?: boolean
    stamina?: boolean
  }

  export type PlayerPoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    playerIndex?: boolean | PlayerDefaultArgs<ExtArgs>
    squard?: boolean | PlayerPool$squardArgs<ExtArgs>
  }

  export type $PlayerPoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerPool"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      playerIndex: Prisma.$PlayerPayload<ExtArgs>
      squard: Prisma.$SquardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      playerId: number
      createdAt: Date
      playerLevel: number
      playerName: string
      count: number
      sidelined: boolean
      stamina: number
    }, ExtArgs["result"]["playerPool"]>
    composites: {}
  }

  type PlayerPoolGetPayload<S extends boolean | null | undefined | PlayerPoolDefaultArgs> = $Result.GetResult<Prisma.$PlayerPoolPayload, S>

  type PlayerPoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerPoolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerPoolCountAggregateInputType | true
    }

  export interface PlayerPoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerPool'], meta: { name: 'PlayerPool' } }
    /**
     * Find zero or one PlayerPool that matches the filter.
     * @param {PlayerPoolFindUniqueArgs} args - Arguments to find a PlayerPool
     * @example
     * // Get one PlayerPool
     * const playerPool = await prisma.playerPool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerPoolFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerPoolFindUniqueArgs<ExtArgs>>
    ): Prisma__PlayerPoolClient<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PlayerPool that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerPoolFindUniqueOrThrowArgs} args - Arguments to find a PlayerPool
     * @example
     * // Get one PlayerPool
     * const playerPool = await prisma.playerPool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlayerPoolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerPoolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PlayerPoolClient<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PlayerPool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPoolFindFirstArgs} args - Arguments to find a PlayerPool
     * @example
     * // Get one PlayerPool
     * const playerPool = await prisma.playerPool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerPoolFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerPoolFindFirstArgs<ExtArgs>>
    ): Prisma__PlayerPoolClient<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PlayerPool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPoolFindFirstOrThrowArgs} args - Arguments to find a PlayerPool
     * @example
     * // Get one PlayerPool
     * const playerPool = await prisma.playerPool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlayerPoolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerPoolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PlayerPoolClient<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PlayerPools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerPools
     * const playerPools = await prisma.playerPool.findMany()
     * 
     * // Get first 10 PlayerPools
     * const playerPools = await prisma.playerPool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerPoolWithIdOnly = await prisma.playerPool.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerPoolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerPoolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PlayerPool.
     * @param {PlayerPoolCreateArgs} args - Arguments to create a PlayerPool.
     * @example
     * // Create one PlayerPool
     * const PlayerPool = await prisma.playerPool.create({
     *   data: {
     *     // ... data to create a PlayerPool
     *   }
     * })
     * 
    **/
    create<T extends PlayerPoolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerPoolCreateArgs<ExtArgs>>
    ): Prisma__PlayerPoolClient<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PlayerPools.
     * @param {PlayerPoolCreateManyArgs} args - Arguments to create many PlayerPools.
     * @example
     * // Create many PlayerPools
     * const playerPool = await prisma.playerPool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PlayerPoolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerPoolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlayerPool.
     * @param {PlayerPoolDeleteArgs} args - Arguments to delete one PlayerPool.
     * @example
     * // Delete one PlayerPool
     * const PlayerPool = await prisma.playerPool.delete({
     *   where: {
     *     // ... filter to delete one PlayerPool
     *   }
     * })
     * 
    **/
    delete<T extends PlayerPoolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerPoolDeleteArgs<ExtArgs>>
    ): Prisma__PlayerPoolClient<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PlayerPool.
     * @param {PlayerPoolUpdateArgs} args - Arguments to update one PlayerPool.
     * @example
     * // Update one PlayerPool
     * const playerPool = await prisma.playerPool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerPoolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerPoolUpdateArgs<ExtArgs>>
    ): Prisma__PlayerPoolClient<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PlayerPools.
     * @param {PlayerPoolDeleteManyArgs} args - Arguments to filter PlayerPools to delete.
     * @example
     * // Delete a few PlayerPools
     * const { count } = await prisma.playerPool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerPoolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerPoolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerPools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerPools
     * const playerPool = await prisma.playerPool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerPoolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerPoolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerPool.
     * @param {PlayerPoolUpsertArgs} args - Arguments to update or create a PlayerPool.
     * @example
     * // Update or create a PlayerPool
     * const playerPool = await prisma.playerPool.upsert({
     *   create: {
     *     // ... data to create a PlayerPool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerPool we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerPoolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerPoolUpsertArgs<ExtArgs>>
    ): Prisma__PlayerPoolClient<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PlayerPools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPoolCountArgs} args - Arguments to filter PlayerPools to count.
     * @example
     * // Count the number of PlayerPools
     * const count = await prisma.playerPool.count({
     *   where: {
     *     // ... the filter for the PlayerPools we want to count
     *   }
     * })
    **/
    count<T extends PlayerPoolCountArgs>(
      args?: Subset<T, PlayerPoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerPoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerPool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerPoolAggregateArgs>(args: Subset<T, PlayerPoolAggregateArgs>): Prisma.PrismaPromise<GetPlayerPoolAggregateType<T>>

    /**
     * Group by PlayerPool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerPoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerPoolGroupByArgs['orderBy'] }
        : { orderBy?: PlayerPoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerPoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerPoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerPool model
   */
  readonly fields: PlayerPoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerPool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerPoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    playerIndex<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    squard<T extends PlayerPool$squardArgs<ExtArgs> = {}>(args?: Subset<T, PlayerPool$squardArgs<ExtArgs>>): Prisma__SquardClient<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PlayerPool model
   */ 
  interface PlayerPoolFieldRefs {
    readonly id: FieldRef<"PlayerPool", 'Int'>
    readonly userId: FieldRef<"PlayerPool", 'Int'>
    readonly playerId: FieldRef<"PlayerPool", 'Int'>
    readonly createdAt: FieldRef<"PlayerPool", 'DateTime'>
    readonly playerLevel: FieldRef<"PlayerPool", 'Int'>
    readonly playerName: FieldRef<"PlayerPool", 'String'>
    readonly count: FieldRef<"PlayerPool", 'Int'>
    readonly sidelined: FieldRef<"PlayerPool", 'Boolean'>
    readonly stamina: FieldRef<"PlayerPool", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlayerPool findUnique
   */
  export type PlayerPoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPool to fetch.
     */
    where: PlayerPoolWhereUniqueInput
  }

  /**
   * PlayerPool findUniqueOrThrow
   */
  export type PlayerPoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPool to fetch.
     */
    where: PlayerPoolWhereUniqueInput
  }

  /**
   * PlayerPool findFirst
   */
  export type PlayerPoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPool to fetch.
     */
    where?: PlayerPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPools to fetch.
     */
    orderBy?: PlayerPoolOrderByWithRelationInput | PlayerPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerPools.
     */
    cursor?: PlayerPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerPools.
     */
    distinct?: PlayerPoolScalarFieldEnum | PlayerPoolScalarFieldEnum[]
  }

  /**
   * PlayerPool findFirstOrThrow
   */
  export type PlayerPoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPool to fetch.
     */
    where?: PlayerPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPools to fetch.
     */
    orderBy?: PlayerPoolOrderByWithRelationInput | PlayerPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerPools.
     */
    cursor?: PlayerPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerPools.
     */
    distinct?: PlayerPoolScalarFieldEnum | PlayerPoolScalarFieldEnum[]
  }

  /**
   * PlayerPool findMany
   */
  export type PlayerPoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPools to fetch.
     */
    where?: PlayerPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPools to fetch.
     */
    orderBy?: PlayerPoolOrderByWithRelationInput | PlayerPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerPools.
     */
    cursor?: PlayerPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPools.
     */
    skip?: number
    distinct?: PlayerPoolScalarFieldEnum | PlayerPoolScalarFieldEnum[]
  }

  /**
   * PlayerPool create
   */
  export type PlayerPoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerPool.
     */
    data: XOR<PlayerPoolCreateInput, PlayerPoolUncheckedCreateInput>
  }

  /**
   * PlayerPool createMany
   */
  export type PlayerPoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerPools.
     */
    data: PlayerPoolCreateManyInput | PlayerPoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerPool update
   */
  export type PlayerPoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerPool.
     */
    data: XOR<PlayerPoolUpdateInput, PlayerPoolUncheckedUpdateInput>
    /**
     * Choose, which PlayerPool to update.
     */
    where: PlayerPoolWhereUniqueInput
  }

  /**
   * PlayerPool updateMany
   */
  export type PlayerPoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerPools.
     */
    data: XOR<PlayerPoolUpdateManyMutationInput, PlayerPoolUncheckedUpdateManyInput>
    /**
     * Filter which PlayerPools to update
     */
    where?: PlayerPoolWhereInput
  }

  /**
   * PlayerPool upsert
   */
  export type PlayerPoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerPool to update in case it exists.
     */
    where: PlayerPoolWhereUniqueInput
    /**
     * In case the PlayerPool found by the `where` argument doesn't exist, create a new PlayerPool with this data.
     */
    create: XOR<PlayerPoolCreateInput, PlayerPoolUncheckedCreateInput>
    /**
     * In case the PlayerPool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerPoolUpdateInput, PlayerPoolUncheckedUpdateInput>
  }

  /**
   * PlayerPool delete
   */
  export type PlayerPoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
    /**
     * Filter which PlayerPool to delete.
     */
    where: PlayerPoolWhereUniqueInput
  }

  /**
   * PlayerPool deleteMany
   */
  export type PlayerPoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerPools to delete
     */
    where?: PlayerPoolWhereInput
  }

  /**
   * PlayerPool.squard
   */
  export type PlayerPool$squardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    where?: SquardWhereInput
  }

  /**
   * PlayerPool without action
   */
  export type PlayerPoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPool
     */
    select?: PlayerPoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPoolInclude<ExtArgs> | null
  }


  /**
   * Model Squard
   */

  export type AggregateSquard = {
    _count: SquardCountAggregateOutputType | null
    _avg: SquardAvgAggregateOutputType | null
    _sum: SquardSumAggregateOutputType | null
    _min: SquardMinAggregateOutputType | null
    _max: SquardMaxAggregateOutputType | null
  }

  export type SquardAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    playerPoolId: number | null
  }

  export type SquardSumAggregateOutputType = {
    id: number | null
    userId: number | null
    playerPoolId: number | null
  }

  export type SquardMinAggregateOutputType = {
    id: number | null
    userId: number | null
    playerPoolId: number | null
  }

  export type SquardMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    playerPoolId: number | null
  }

  export type SquardCountAggregateOutputType = {
    id: number
    userId: number
    playerPoolId: number
    _all: number
  }


  export type SquardAvgAggregateInputType = {
    id?: true
    userId?: true
    playerPoolId?: true
  }

  export type SquardSumAggregateInputType = {
    id?: true
    userId?: true
    playerPoolId?: true
  }

  export type SquardMinAggregateInputType = {
    id?: true
    userId?: true
    playerPoolId?: true
  }

  export type SquardMaxAggregateInputType = {
    id?: true
    userId?: true
    playerPoolId?: true
  }

  export type SquardCountAggregateInputType = {
    id?: true
    userId?: true
    playerPoolId?: true
    _all?: true
  }

  export type SquardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Squard to aggregate.
     */
    where?: SquardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Squards to fetch.
     */
    orderBy?: SquardOrderByWithRelationInput | SquardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SquardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Squards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Squards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Squards
    **/
    _count?: true | SquardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SquardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SquardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SquardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SquardMaxAggregateInputType
  }

  export type GetSquardAggregateType<T extends SquardAggregateArgs> = {
        [P in keyof T & keyof AggregateSquard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSquard[P]>
      : GetScalarType<T[P], AggregateSquard[P]>
  }




  export type SquardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SquardWhereInput
    orderBy?: SquardOrderByWithAggregationInput | SquardOrderByWithAggregationInput[]
    by: SquardScalarFieldEnum[] | SquardScalarFieldEnum
    having?: SquardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SquardCountAggregateInputType | true
    _avg?: SquardAvgAggregateInputType
    _sum?: SquardSumAggregateInputType
    _min?: SquardMinAggregateInputType
    _max?: SquardMaxAggregateInputType
  }

  export type SquardGroupByOutputType = {
    id: number
    userId: number
    playerPoolId: number
    _count: SquardCountAggregateOutputType | null
    _avg: SquardAvgAggregateOutputType | null
    _sum: SquardSumAggregateOutputType | null
    _min: SquardMinAggregateOutputType | null
    _max: SquardMaxAggregateOutputType | null
  }

  type GetSquardGroupByPayload<T extends SquardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SquardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SquardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SquardGroupByOutputType[P]>
            : GetScalarType<T[P], SquardGroupByOutputType[P]>
        }
      >
    >


  export type SquardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    playerPoolId?: boolean
    playerPool?: boolean | PlayerPoolDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["squard"]>


  export type SquardSelectScalar = {
    id?: boolean
    userId?: boolean
    playerPoolId?: boolean
  }

  export type SquardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerPool?: boolean | PlayerPoolDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SquardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Squard"
    objects: {
      playerPool: Prisma.$PlayerPoolPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      playerPoolId: number
    }, ExtArgs["result"]["squard"]>
    composites: {}
  }

  type SquardGetPayload<S extends boolean | null | undefined | SquardDefaultArgs> = $Result.GetResult<Prisma.$SquardPayload, S>

  type SquardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SquardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SquardCountAggregateInputType | true
    }

  export interface SquardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Squard'], meta: { name: 'Squard' } }
    /**
     * Find zero or one Squard that matches the filter.
     * @param {SquardFindUniqueArgs} args - Arguments to find a Squard
     * @example
     * // Get one Squard
     * const squard = await prisma.squard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SquardFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SquardFindUniqueArgs<ExtArgs>>
    ): Prisma__SquardClient<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Squard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SquardFindUniqueOrThrowArgs} args - Arguments to find a Squard
     * @example
     * // Get one Squard
     * const squard = await prisma.squard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SquardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SquardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SquardClient<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Squard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SquardFindFirstArgs} args - Arguments to find a Squard
     * @example
     * // Get one Squard
     * const squard = await prisma.squard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SquardFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SquardFindFirstArgs<ExtArgs>>
    ): Prisma__SquardClient<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Squard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SquardFindFirstOrThrowArgs} args - Arguments to find a Squard
     * @example
     * // Get one Squard
     * const squard = await prisma.squard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SquardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SquardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SquardClient<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Squards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SquardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Squards
     * const squards = await prisma.squard.findMany()
     * 
     * // Get first 10 Squards
     * const squards = await prisma.squard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const squardWithIdOnly = await prisma.squard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SquardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SquardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Squard.
     * @param {SquardCreateArgs} args - Arguments to create a Squard.
     * @example
     * // Create one Squard
     * const Squard = await prisma.squard.create({
     *   data: {
     *     // ... data to create a Squard
     *   }
     * })
     * 
    **/
    create<T extends SquardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SquardCreateArgs<ExtArgs>>
    ): Prisma__SquardClient<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Squards.
     * @param {SquardCreateManyArgs} args - Arguments to create many Squards.
     * @example
     * // Create many Squards
     * const squard = await prisma.squard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends SquardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SquardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Squard.
     * @param {SquardDeleteArgs} args - Arguments to delete one Squard.
     * @example
     * // Delete one Squard
     * const Squard = await prisma.squard.delete({
     *   where: {
     *     // ... filter to delete one Squard
     *   }
     * })
     * 
    **/
    delete<T extends SquardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SquardDeleteArgs<ExtArgs>>
    ): Prisma__SquardClient<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Squard.
     * @param {SquardUpdateArgs} args - Arguments to update one Squard.
     * @example
     * // Update one Squard
     * const squard = await prisma.squard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SquardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SquardUpdateArgs<ExtArgs>>
    ): Prisma__SquardClient<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Squards.
     * @param {SquardDeleteManyArgs} args - Arguments to filter Squards to delete.
     * @example
     * // Delete a few Squards
     * const { count } = await prisma.squard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SquardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SquardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Squards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SquardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Squards
     * const squard = await prisma.squard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SquardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SquardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Squard.
     * @param {SquardUpsertArgs} args - Arguments to update or create a Squard.
     * @example
     * // Update or create a Squard
     * const squard = await prisma.squard.upsert({
     *   create: {
     *     // ... data to create a Squard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Squard we want to update
     *   }
     * })
    **/
    upsert<T extends SquardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SquardUpsertArgs<ExtArgs>>
    ): Prisma__SquardClient<$Result.GetResult<Prisma.$SquardPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Squards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SquardCountArgs} args - Arguments to filter Squards to count.
     * @example
     * // Count the number of Squards
     * const count = await prisma.squard.count({
     *   where: {
     *     // ... the filter for the Squards we want to count
     *   }
     * })
    **/
    count<T extends SquardCountArgs>(
      args?: Subset<T, SquardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SquardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Squard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SquardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SquardAggregateArgs>(args: Subset<T, SquardAggregateArgs>): Prisma.PrismaPromise<GetSquardAggregateType<T>>

    /**
     * Group by Squard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SquardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SquardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SquardGroupByArgs['orderBy'] }
        : { orderBy?: SquardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SquardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSquardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Squard model
   */
  readonly fields: SquardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Squard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SquardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    playerPool<T extends PlayerPoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerPoolDefaultArgs<ExtArgs>>): Prisma__PlayerPoolClient<$Result.GetResult<Prisma.$PlayerPoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Squard model
   */ 
  interface SquardFieldRefs {
    readonly id: FieldRef<"Squard", 'Int'>
    readonly userId: FieldRef<"Squard", 'Int'>
    readonly playerPoolId: FieldRef<"Squard", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Squard findUnique
   */
  export type SquardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    /**
     * Filter, which Squard to fetch.
     */
    where: SquardWhereUniqueInput
  }

  /**
   * Squard findUniqueOrThrow
   */
  export type SquardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    /**
     * Filter, which Squard to fetch.
     */
    where: SquardWhereUniqueInput
  }

  /**
   * Squard findFirst
   */
  export type SquardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    /**
     * Filter, which Squard to fetch.
     */
    where?: SquardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Squards to fetch.
     */
    orderBy?: SquardOrderByWithRelationInput | SquardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Squards.
     */
    cursor?: SquardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Squards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Squards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Squards.
     */
    distinct?: SquardScalarFieldEnum | SquardScalarFieldEnum[]
  }

  /**
   * Squard findFirstOrThrow
   */
  export type SquardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    /**
     * Filter, which Squard to fetch.
     */
    where?: SquardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Squards to fetch.
     */
    orderBy?: SquardOrderByWithRelationInput | SquardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Squards.
     */
    cursor?: SquardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Squards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Squards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Squards.
     */
    distinct?: SquardScalarFieldEnum | SquardScalarFieldEnum[]
  }

  /**
   * Squard findMany
   */
  export type SquardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    /**
     * Filter, which Squards to fetch.
     */
    where?: SquardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Squards to fetch.
     */
    orderBy?: SquardOrderByWithRelationInput | SquardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Squards.
     */
    cursor?: SquardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Squards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Squards.
     */
    skip?: number
    distinct?: SquardScalarFieldEnum | SquardScalarFieldEnum[]
  }

  /**
   * Squard create
   */
  export type SquardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    /**
     * The data needed to create a Squard.
     */
    data: XOR<SquardCreateInput, SquardUncheckedCreateInput>
  }

  /**
   * Squard createMany
   */
  export type SquardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Squards.
     */
    data: SquardCreateManyInput | SquardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Squard update
   */
  export type SquardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    /**
     * The data needed to update a Squard.
     */
    data: XOR<SquardUpdateInput, SquardUncheckedUpdateInput>
    /**
     * Choose, which Squard to update.
     */
    where: SquardWhereUniqueInput
  }

  /**
   * Squard updateMany
   */
  export type SquardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Squards.
     */
    data: XOR<SquardUpdateManyMutationInput, SquardUncheckedUpdateManyInput>
    /**
     * Filter which Squards to update
     */
    where?: SquardWhereInput
  }

  /**
   * Squard upsert
   */
  export type SquardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    /**
     * The filter to search for the Squard to update in case it exists.
     */
    where: SquardWhereUniqueInput
    /**
     * In case the Squard found by the `where` argument doesn't exist, create a new Squard with this data.
     */
    create: XOR<SquardCreateInput, SquardUncheckedCreateInput>
    /**
     * In case the Squard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SquardUpdateInput, SquardUncheckedUpdateInput>
  }

  /**
   * Squard delete
   */
  export type SquardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
    /**
     * Filter which Squard to delete.
     */
    where: SquardWhereUniqueInput
  }

  /**
   * Squard deleteMany
   */
  export type SquardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Squards to delete
     */
    where?: SquardWhereInput
  }

  /**
   * Squard without action
   */
  export type SquardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Squard
     */
    select?: SquardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SquardInclude<ExtArgs> | null
  }


  /**
   * Model Matching
   */

  export type AggregateMatching = {
    _count: MatchingCountAggregateOutputType | null
    _avg: MatchingAvgAggregateOutputType | null
    _sum: MatchingSumAggregateOutputType | null
    _min: MatchingMinAggregateOutputType | null
    _max: MatchingMaxAggregateOutputType | null
  }

  export type MatchingAvgAggregateOutputType = {
    id: number | null
    userHomeId: number | null
    userAwayId: number | null
  }

  export type MatchingSumAggregateOutputType = {
    id: number | null
    userHomeId: number | null
    userAwayId: number | null
  }

  export type MatchingMinAggregateOutputType = {
    id: number | null
    userHomeId: number | null
    userAwayId: number | null
    result: string | null
  }

  export type MatchingMaxAggregateOutputType = {
    id: number | null
    userHomeId: number | null
    userAwayId: number | null
    result: string | null
  }

  export type MatchingCountAggregateOutputType = {
    id: number
    userHomeId: number
    userAwayId: number
    result: number
    _all: number
  }


  export type MatchingAvgAggregateInputType = {
    id?: true
    userHomeId?: true
    userAwayId?: true
  }

  export type MatchingSumAggregateInputType = {
    id?: true
    userHomeId?: true
    userAwayId?: true
  }

  export type MatchingMinAggregateInputType = {
    id?: true
    userHomeId?: true
    userAwayId?: true
    result?: true
  }

  export type MatchingMaxAggregateInputType = {
    id?: true
    userHomeId?: true
    userAwayId?: true
    result?: true
  }

  export type MatchingCountAggregateInputType = {
    id?: true
    userHomeId?: true
    userAwayId?: true
    result?: true
    _all?: true
  }

  export type MatchingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matching to aggregate.
     */
    where?: MatchingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matchings to fetch.
     */
    orderBy?: MatchingOrderByWithRelationInput | MatchingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matchings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matchings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matchings
    **/
    _count?: true | MatchingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchingMaxAggregateInputType
  }

  export type GetMatchingAggregateType<T extends MatchingAggregateArgs> = {
        [P in keyof T & keyof AggregateMatching]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatching[P]>
      : GetScalarType<T[P], AggregateMatching[P]>
  }




  export type MatchingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchingWhereInput
    orderBy?: MatchingOrderByWithAggregationInput | MatchingOrderByWithAggregationInput[]
    by: MatchingScalarFieldEnum[] | MatchingScalarFieldEnum
    having?: MatchingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchingCountAggregateInputType | true
    _avg?: MatchingAvgAggregateInputType
    _sum?: MatchingSumAggregateInputType
    _min?: MatchingMinAggregateInputType
    _max?: MatchingMaxAggregateInputType
  }

  export type MatchingGroupByOutputType = {
    id: number
    userHomeId: number
    userAwayId: number
    result: string
    _count: MatchingCountAggregateOutputType | null
    _avg: MatchingAvgAggregateOutputType | null
    _sum: MatchingSumAggregateOutputType | null
    _min: MatchingMinAggregateOutputType | null
    _max: MatchingMaxAggregateOutputType | null
  }

  type GetMatchingGroupByPayload<T extends MatchingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchingGroupByOutputType[P]>
            : GetScalarType<T[P], MatchingGroupByOutputType[P]>
        }
      >
    >


  export type MatchingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userHomeId?: boolean
    userAwayId?: boolean
    result?: boolean
    userHome?: boolean | UserDefaultArgs<ExtArgs>
    userAway?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matching"]>


  export type MatchingSelectScalar = {
    id?: boolean
    userHomeId?: boolean
    userAwayId?: boolean
    result?: boolean
  }

  export type MatchingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userHome?: boolean | UserDefaultArgs<ExtArgs>
    userAway?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Matching"
    objects: {
      userHome: Prisma.$UserPayload<ExtArgs>
      userAway: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userHomeId: number
      userAwayId: number
      result: string
    }, ExtArgs["result"]["matching"]>
    composites: {}
  }

  type MatchingGetPayload<S extends boolean | null | undefined | MatchingDefaultArgs> = $Result.GetResult<Prisma.$MatchingPayload, S>

  type MatchingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatchingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatchingCountAggregateInputType | true
    }

  export interface MatchingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Matching'], meta: { name: 'Matching' } }
    /**
     * Find zero or one Matching that matches the filter.
     * @param {MatchingFindUniqueArgs} args - Arguments to find a Matching
     * @example
     * // Get one Matching
     * const matching = await prisma.matching.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MatchingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MatchingFindUniqueArgs<ExtArgs>>
    ): Prisma__MatchingClient<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Matching that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatchingFindUniqueOrThrowArgs} args - Arguments to find a Matching
     * @example
     * // Get one Matching
     * const matching = await prisma.matching.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MatchingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MatchingClient<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Matching that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchingFindFirstArgs} args - Arguments to find a Matching
     * @example
     * // Get one Matching
     * const matching = await prisma.matching.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MatchingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchingFindFirstArgs<ExtArgs>>
    ): Prisma__MatchingClient<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Matching that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchingFindFirstOrThrowArgs} args - Arguments to find a Matching
     * @example
     * // Get one Matching
     * const matching = await prisma.matching.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MatchingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MatchingClient<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Matchings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matchings
     * const matchings = await prisma.matching.findMany()
     * 
     * // Get first 10 Matchings
     * const matchings = await prisma.matching.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchingWithIdOnly = await prisma.matching.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MatchingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Matching.
     * @param {MatchingCreateArgs} args - Arguments to create a Matching.
     * @example
     * // Create one Matching
     * const Matching = await prisma.matching.create({
     *   data: {
     *     // ... data to create a Matching
     *   }
     * })
     * 
    **/
    create<T extends MatchingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MatchingCreateArgs<ExtArgs>>
    ): Prisma__MatchingClient<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Matchings.
     * @param {MatchingCreateManyArgs} args - Arguments to create many Matchings.
     * @example
     * // Create many Matchings
     * const matching = await prisma.matching.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends MatchingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Matching.
     * @param {MatchingDeleteArgs} args - Arguments to delete one Matching.
     * @example
     * // Delete one Matching
     * const Matching = await prisma.matching.delete({
     *   where: {
     *     // ... filter to delete one Matching
     *   }
     * })
     * 
    **/
    delete<T extends MatchingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MatchingDeleteArgs<ExtArgs>>
    ): Prisma__MatchingClient<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Matching.
     * @param {MatchingUpdateArgs} args - Arguments to update one Matching.
     * @example
     * // Update one Matching
     * const matching = await prisma.matching.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MatchingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MatchingUpdateArgs<ExtArgs>>
    ): Prisma__MatchingClient<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Matchings.
     * @param {MatchingDeleteManyArgs} args - Arguments to filter Matchings to delete.
     * @example
     * // Delete a few Matchings
     * const { count } = await prisma.matching.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MatchingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matchings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matchings
     * const matching = await prisma.matching.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MatchingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MatchingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Matching.
     * @param {MatchingUpsertArgs} args - Arguments to update or create a Matching.
     * @example
     * // Update or create a Matching
     * const matching = await prisma.matching.upsert({
     *   create: {
     *     // ... data to create a Matching
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Matching we want to update
     *   }
     * })
    **/
    upsert<T extends MatchingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MatchingUpsertArgs<ExtArgs>>
    ): Prisma__MatchingClient<$Result.GetResult<Prisma.$MatchingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Matchings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchingCountArgs} args - Arguments to filter Matchings to count.
     * @example
     * // Count the number of Matchings
     * const count = await prisma.matching.count({
     *   where: {
     *     // ... the filter for the Matchings we want to count
     *   }
     * })
    **/
    count<T extends MatchingCountArgs>(
      args?: Subset<T, MatchingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Matching.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchingAggregateArgs>(args: Subset<T, MatchingAggregateArgs>): Prisma.PrismaPromise<GetMatchingAggregateType<T>>

    /**
     * Group by Matching.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchingGroupByArgs['orderBy'] }
        : { orderBy?: MatchingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Matching model
   */
  readonly fields: MatchingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Matching.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    userHome<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    userAway<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Matching model
   */ 
  interface MatchingFieldRefs {
    readonly id: FieldRef<"Matching", 'Int'>
    readonly userHomeId: FieldRef<"Matching", 'Int'>
    readonly userAwayId: FieldRef<"Matching", 'Int'>
    readonly result: FieldRef<"Matching", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Matching findUnique
   */
  export type MatchingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    /**
     * Filter, which Matching to fetch.
     */
    where: MatchingWhereUniqueInput
  }

  /**
   * Matching findUniqueOrThrow
   */
  export type MatchingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    /**
     * Filter, which Matching to fetch.
     */
    where: MatchingWhereUniqueInput
  }

  /**
   * Matching findFirst
   */
  export type MatchingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    /**
     * Filter, which Matching to fetch.
     */
    where?: MatchingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matchings to fetch.
     */
    orderBy?: MatchingOrderByWithRelationInput | MatchingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matchings.
     */
    cursor?: MatchingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matchings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matchings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matchings.
     */
    distinct?: MatchingScalarFieldEnum | MatchingScalarFieldEnum[]
  }

  /**
   * Matching findFirstOrThrow
   */
  export type MatchingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    /**
     * Filter, which Matching to fetch.
     */
    where?: MatchingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matchings to fetch.
     */
    orderBy?: MatchingOrderByWithRelationInput | MatchingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matchings.
     */
    cursor?: MatchingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matchings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matchings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matchings.
     */
    distinct?: MatchingScalarFieldEnum | MatchingScalarFieldEnum[]
  }

  /**
   * Matching findMany
   */
  export type MatchingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    /**
     * Filter, which Matchings to fetch.
     */
    where?: MatchingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matchings to fetch.
     */
    orderBy?: MatchingOrderByWithRelationInput | MatchingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matchings.
     */
    cursor?: MatchingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matchings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matchings.
     */
    skip?: number
    distinct?: MatchingScalarFieldEnum | MatchingScalarFieldEnum[]
  }

  /**
   * Matching create
   */
  export type MatchingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    /**
     * The data needed to create a Matching.
     */
    data: XOR<MatchingCreateInput, MatchingUncheckedCreateInput>
  }

  /**
   * Matching createMany
   */
  export type MatchingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matchings.
     */
    data: MatchingCreateManyInput | MatchingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Matching update
   */
  export type MatchingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    /**
     * The data needed to update a Matching.
     */
    data: XOR<MatchingUpdateInput, MatchingUncheckedUpdateInput>
    /**
     * Choose, which Matching to update.
     */
    where: MatchingWhereUniqueInput
  }

  /**
   * Matching updateMany
   */
  export type MatchingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matchings.
     */
    data: XOR<MatchingUpdateManyMutationInput, MatchingUncheckedUpdateManyInput>
    /**
     * Filter which Matchings to update
     */
    where?: MatchingWhereInput
  }

  /**
   * Matching upsert
   */
  export type MatchingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    /**
     * The filter to search for the Matching to update in case it exists.
     */
    where: MatchingWhereUniqueInput
    /**
     * In case the Matching found by the `where` argument doesn't exist, create a new Matching with this data.
     */
    create: XOR<MatchingCreateInput, MatchingUncheckedCreateInput>
    /**
     * In case the Matching was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchingUpdateInput, MatchingUncheckedUpdateInput>
  }

  /**
   * Matching delete
   */
  export type MatchingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
    /**
     * Filter which Matching to delete.
     */
    where: MatchingWhereUniqueInput
  }

  /**
   * Matching deleteMany
   */
  export type MatchingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matchings to delete
     */
    where?: MatchingWhereInput
  }

  /**
   * Matching without action
   */
  export type MatchingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matching
     */
    select?: MatchingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    accountName: 'accountName',
    password: 'password',
    createdAt: 'createdAt',
    cash: 'cash',
    mmr: 'mmr'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserTopRankingsScalarFieldEnum: {
    userId: 'userId',
    rank: 'rank',
    mmr: 'mmr'
  };

  export type UserTopRankingsScalarFieldEnum = (typeof UserTopRankingsScalarFieldEnum)[keyof typeof UserTopRankingsScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    speed: 'speed',
    passing: 'passing',
    dribbling: 'dribbling',
    heading: 'heading',
    shooting: 'shooting',
    tackling: 'tackling',
    marking: 'marking',
    strength: 'strength',
    weight: 'weight',
    nationality: 'nationality'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const PlayerPoolScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    playerId: 'playerId',
    createdAt: 'createdAt',
    playerLevel: 'playerLevel',
    playerName: 'playerName',
    count: 'count',
    sidelined: 'sidelined',
    stamina: 'stamina'
  };

  export type PlayerPoolScalarFieldEnum = (typeof PlayerPoolScalarFieldEnum)[keyof typeof PlayerPoolScalarFieldEnum]


  export const SquardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    playerPoolId: 'playerPoolId'
  };

  export type SquardScalarFieldEnum = (typeof SquardScalarFieldEnum)[keyof typeof SquardScalarFieldEnum]


  export const MatchingScalarFieldEnum: {
    id: 'id',
    userHomeId: 'userHomeId',
    userAwayId: 'userAwayId',
    result: 'result'
  };

  export type MatchingScalarFieldEnum = (typeof MatchingScalarFieldEnum)[keyof typeof MatchingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    accountName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    cash?: IntFilter<"User"> | number
    mmr?: IntFilter<"User"> | number
    playerPool?: PlayerPoolListRelationFilter
    squard?: SquardListRelationFilter
    home?: MatchingListRelationFilter
    away?: MatchingListRelationFilter
    rank?: XOR<UserTopRankingsNullableRelationFilter, UserTopRankingsWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    accountName?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    cash?: SortOrder
    mmr?: SortOrder
    playerPool?: PlayerPoolOrderByRelationAggregateInput
    squard?: SquardOrderByRelationAggregateInput
    home?: MatchingOrderByRelationAggregateInput
    away?: MatchingOrderByRelationAggregateInput
    rank?: UserTopRankingsOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    accountName?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    cash?: IntFilter<"User"> | number
    mmr?: IntFilter<"User"> | number
    playerPool?: PlayerPoolListRelationFilter
    squard?: SquardListRelationFilter
    home?: MatchingListRelationFilter
    away?: MatchingListRelationFilter
    rank?: XOR<UserTopRankingsNullableRelationFilter, UserTopRankingsWhereInput> | null
  }, "id" | "accountName">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    accountName?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    cash?: SortOrder
    mmr?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    accountName?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    cash?: IntWithAggregatesFilter<"User"> | number
    mmr?: IntWithAggregatesFilter<"User"> | number
  }

  export type UserTopRankingsWhereInput = {
    AND?: UserTopRankingsWhereInput | UserTopRankingsWhereInput[]
    OR?: UserTopRankingsWhereInput[]
    NOT?: UserTopRankingsWhereInput | UserTopRankingsWhereInput[]
    userId?: IntFilter<"UserTopRankings"> | number
    rank?: IntFilter<"UserTopRankings"> | number
    mmr?: IntFilter<"UserTopRankings"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserTopRankingsOrderByWithRelationInput = {
    userId?: SortOrder
    rank?: SortOrder
    mmr?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserTopRankingsWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: UserTopRankingsWhereInput | UserTopRankingsWhereInput[]
    OR?: UserTopRankingsWhereInput[]
    NOT?: UserTopRankingsWhereInput | UserTopRankingsWhereInput[]
    rank?: IntFilter<"UserTopRankings"> | number
    mmr?: IntFilter<"UserTopRankings"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId">

  export type UserTopRankingsOrderByWithAggregationInput = {
    userId?: SortOrder
    rank?: SortOrder
    mmr?: SortOrder
    _count?: UserTopRankingsCountOrderByAggregateInput
    _avg?: UserTopRankingsAvgOrderByAggregateInput
    _max?: UserTopRankingsMaxOrderByAggregateInput
    _min?: UserTopRankingsMinOrderByAggregateInput
    _sum?: UserTopRankingsSumOrderByAggregateInput
  }

  export type UserTopRankingsScalarWhereWithAggregatesInput = {
    AND?: UserTopRankingsScalarWhereWithAggregatesInput | UserTopRankingsScalarWhereWithAggregatesInput[]
    OR?: UserTopRankingsScalarWhereWithAggregatesInput[]
    NOT?: UserTopRankingsScalarWhereWithAggregatesInput | UserTopRankingsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserTopRankings"> | number
    rank?: IntWithAggregatesFilter<"UserTopRankings"> | number
    mmr?: IntWithAggregatesFilter<"UserTopRankings"> | number
  }

  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: IntFilter<"Player"> | number
    name?: StringFilter<"Player"> | string
    speed?: IntFilter<"Player"> | number
    passing?: IntFilter<"Player"> | number
    dribbling?: IntFilter<"Player"> | number
    heading?: IntFilter<"Player"> | number
    shooting?: IntFilter<"Player"> | number
    tackling?: IntFilter<"Player"> | number
    marking?: IntFilter<"Player"> | number
    strength?: IntFilter<"Player"> | number
    weight?: IntFilter<"Player"> | number
    nationality?: StringFilter<"Player"> | string
    playerPool?: PlayerPoolListRelationFilter
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    speed?: SortOrder
    passing?: SortOrder
    dribbling?: SortOrder
    heading?: SortOrder
    shooting?: SortOrder
    tackling?: SortOrder
    marking?: SortOrder
    strength?: SortOrder
    weight?: SortOrder
    nationality?: SortOrder
    playerPool?: PlayerPoolOrderByRelationAggregateInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    name?: StringFilter<"Player"> | string
    speed?: IntFilter<"Player"> | number
    passing?: IntFilter<"Player"> | number
    dribbling?: IntFilter<"Player"> | number
    heading?: IntFilter<"Player"> | number
    shooting?: IntFilter<"Player"> | number
    tackling?: IntFilter<"Player"> | number
    marking?: IntFilter<"Player"> | number
    strength?: IntFilter<"Player"> | number
    weight?: IntFilter<"Player"> | number
    nationality?: StringFilter<"Player"> | string
    playerPool?: PlayerPoolListRelationFilter
  }, "id">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    speed?: SortOrder
    passing?: SortOrder
    dribbling?: SortOrder
    heading?: SortOrder
    shooting?: SortOrder
    tackling?: SortOrder
    marking?: SortOrder
    strength?: SortOrder
    weight?: SortOrder
    nationality?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Player"> | number
    name?: StringWithAggregatesFilter<"Player"> | string
    speed?: IntWithAggregatesFilter<"Player"> | number
    passing?: IntWithAggregatesFilter<"Player"> | number
    dribbling?: IntWithAggregatesFilter<"Player"> | number
    heading?: IntWithAggregatesFilter<"Player"> | number
    shooting?: IntWithAggregatesFilter<"Player"> | number
    tackling?: IntWithAggregatesFilter<"Player"> | number
    marking?: IntWithAggregatesFilter<"Player"> | number
    strength?: IntWithAggregatesFilter<"Player"> | number
    weight?: IntWithAggregatesFilter<"Player"> | number
    nationality?: StringWithAggregatesFilter<"Player"> | string
  }

  export type PlayerPoolWhereInput = {
    AND?: PlayerPoolWhereInput | PlayerPoolWhereInput[]
    OR?: PlayerPoolWhereInput[]
    NOT?: PlayerPoolWhereInput | PlayerPoolWhereInput[]
    id?: IntFilter<"PlayerPool"> | number
    userId?: IntFilter<"PlayerPool"> | number
    playerId?: IntFilter<"PlayerPool"> | number
    createdAt?: DateTimeFilter<"PlayerPool"> | Date | string
    playerLevel?: IntFilter<"PlayerPool"> | number
    playerName?: StringFilter<"PlayerPool"> | string
    count?: IntFilter<"PlayerPool"> | number
    sidelined?: BoolFilter<"PlayerPool"> | boolean
    stamina?: IntFilter<"PlayerPool"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    playerIndex?: XOR<PlayerRelationFilter, PlayerWhereInput>
    squard?: XOR<SquardNullableRelationFilter, SquardWhereInput> | null
  }

  export type PlayerPoolOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    createdAt?: SortOrder
    playerLevel?: SortOrder
    playerName?: SortOrder
    count?: SortOrder
    sidelined?: SortOrder
    stamina?: SortOrder
    user?: UserOrderByWithRelationInput
    playerIndex?: PlayerOrderByWithRelationInput
    squard?: SquardOrderByWithRelationInput
  }

  export type PlayerPoolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlayerPoolWhereInput | PlayerPoolWhereInput[]
    OR?: PlayerPoolWhereInput[]
    NOT?: PlayerPoolWhereInput | PlayerPoolWhereInput[]
    userId?: IntFilter<"PlayerPool"> | number
    playerId?: IntFilter<"PlayerPool"> | number
    createdAt?: DateTimeFilter<"PlayerPool"> | Date | string
    playerLevel?: IntFilter<"PlayerPool"> | number
    playerName?: StringFilter<"PlayerPool"> | string
    count?: IntFilter<"PlayerPool"> | number
    sidelined?: BoolFilter<"PlayerPool"> | boolean
    stamina?: IntFilter<"PlayerPool"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    playerIndex?: XOR<PlayerRelationFilter, PlayerWhereInput>
    squard?: XOR<SquardNullableRelationFilter, SquardWhereInput> | null
  }, "id">

  export type PlayerPoolOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    createdAt?: SortOrder
    playerLevel?: SortOrder
    playerName?: SortOrder
    count?: SortOrder
    sidelined?: SortOrder
    stamina?: SortOrder
    _count?: PlayerPoolCountOrderByAggregateInput
    _avg?: PlayerPoolAvgOrderByAggregateInput
    _max?: PlayerPoolMaxOrderByAggregateInput
    _min?: PlayerPoolMinOrderByAggregateInput
    _sum?: PlayerPoolSumOrderByAggregateInput
  }

  export type PlayerPoolScalarWhereWithAggregatesInput = {
    AND?: PlayerPoolScalarWhereWithAggregatesInput | PlayerPoolScalarWhereWithAggregatesInput[]
    OR?: PlayerPoolScalarWhereWithAggregatesInput[]
    NOT?: PlayerPoolScalarWhereWithAggregatesInput | PlayerPoolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlayerPool"> | number
    userId?: IntWithAggregatesFilter<"PlayerPool"> | number
    playerId?: IntWithAggregatesFilter<"PlayerPool"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlayerPool"> | Date | string
    playerLevel?: IntWithAggregatesFilter<"PlayerPool"> | number
    playerName?: StringWithAggregatesFilter<"PlayerPool"> | string
    count?: IntWithAggregatesFilter<"PlayerPool"> | number
    sidelined?: BoolWithAggregatesFilter<"PlayerPool"> | boolean
    stamina?: IntWithAggregatesFilter<"PlayerPool"> | number
  }

  export type SquardWhereInput = {
    AND?: SquardWhereInput | SquardWhereInput[]
    OR?: SquardWhereInput[]
    NOT?: SquardWhereInput | SquardWhereInput[]
    id?: IntFilter<"Squard"> | number
    userId?: IntFilter<"Squard"> | number
    playerPoolId?: IntFilter<"Squard"> | number
    playerPool?: XOR<PlayerPoolRelationFilter, PlayerPoolWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SquardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    playerPoolId?: SortOrder
    playerPool?: PlayerPoolOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SquardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    playerPoolId?: number
    AND?: SquardWhereInput | SquardWhereInput[]
    OR?: SquardWhereInput[]
    NOT?: SquardWhereInput | SquardWhereInput[]
    userId?: IntFilter<"Squard"> | number
    playerPool?: XOR<PlayerPoolRelationFilter, PlayerPoolWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "playerPoolId">

  export type SquardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    playerPoolId?: SortOrder
    _count?: SquardCountOrderByAggregateInput
    _avg?: SquardAvgOrderByAggregateInput
    _max?: SquardMaxOrderByAggregateInput
    _min?: SquardMinOrderByAggregateInput
    _sum?: SquardSumOrderByAggregateInput
  }

  export type SquardScalarWhereWithAggregatesInput = {
    AND?: SquardScalarWhereWithAggregatesInput | SquardScalarWhereWithAggregatesInput[]
    OR?: SquardScalarWhereWithAggregatesInput[]
    NOT?: SquardScalarWhereWithAggregatesInput | SquardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Squard"> | number
    userId?: IntWithAggregatesFilter<"Squard"> | number
    playerPoolId?: IntWithAggregatesFilter<"Squard"> | number
  }

  export type MatchingWhereInput = {
    AND?: MatchingWhereInput | MatchingWhereInput[]
    OR?: MatchingWhereInput[]
    NOT?: MatchingWhereInput | MatchingWhereInput[]
    id?: IntFilter<"Matching"> | number
    userHomeId?: IntFilter<"Matching"> | number
    userAwayId?: IntFilter<"Matching"> | number
    result?: StringFilter<"Matching"> | string
    userHome?: XOR<UserRelationFilter, UserWhereInput>
    userAway?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MatchingOrderByWithRelationInput = {
    id?: SortOrder
    userHomeId?: SortOrder
    userAwayId?: SortOrder
    result?: SortOrder
    userHome?: UserOrderByWithRelationInput
    userAway?: UserOrderByWithRelationInput
  }

  export type MatchingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MatchingWhereInput | MatchingWhereInput[]
    OR?: MatchingWhereInput[]
    NOT?: MatchingWhereInput | MatchingWhereInput[]
    userHomeId?: IntFilter<"Matching"> | number
    userAwayId?: IntFilter<"Matching"> | number
    result?: StringFilter<"Matching"> | string
    userHome?: XOR<UserRelationFilter, UserWhereInput>
    userAway?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MatchingOrderByWithAggregationInput = {
    id?: SortOrder
    userHomeId?: SortOrder
    userAwayId?: SortOrder
    result?: SortOrder
    _count?: MatchingCountOrderByAggregateInput
    _avg?: MatchingAvgOrderByAggregateInput
    _max?: MatchingMaxOrderByAggregateInput
    _min?: MatchingMinOrderByAggregateInput
    _sum?: MatchingSumOrderByAggregateInput
  }

  export type MatchingScalarWhereWithAggregatesInput = {
    AND?: MatchingScalarWhereWithAggregatesInput | MatchingScalarWhereWithAggregatesInput[]
    OR?: MatchingScalarWhereWithAggregatesInput[]
    NOT?: MatchingScalarWhereWithAggregatesInput | MatchingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Matching"> | number
    userHomeId?: IntWithAggregatesFilter<"Matching"> | number
    userAwayId?: IntWithAggregatesFilter<"Matching"> | number
    result?: StringWithAggregatesFilter<"Matching"> | string
  }

  export type UserCreateInput = {
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    playerPool?: PlayerPoolCreateNestedManyWithoutUserInput
    squard?: SquardCreateNestedManyWithoutUserInput
    home?: MatchingCreateNestedManyWithoutUserHomeInput
    away?: MatchingCreateNestedManyWithoutUserAwayInput
    rank?: UserTopRankingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    playerPool?: PlayerPoolUncheckedCreateNestedManyWithoutUserInput
    squard?: SquardUncheckedCreateNestedManyWithoutUserInput
    home?: MatchingUncheckedCreateNestedManyWithoutUserHomeInput
    away?: MatchingUncheckedCreateNestedManyWithoutUserAwayInput
    rank?: UserTopRankingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    playerPool?: PlayerPoolUpdateManyWithoutUserNestedInput
    squard?: SquardUpdateManyWithoutUserNestedInput
    home?: MatchingUpdateManyWithoutUserHomeNestedInput
    away?: MatchingUpdateManyWithoutUserAwayNestedInput
    rank?: UserTopRankingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    playerPool?: PlayerPoolUncheckedUpdateManyWithoutUserNestedInput
    squard?: SquardUncheckedUpdateManyWithoutUserNestedInput
    home?: MatchingUncheckedUpdateManyWithoutUserHomeNestedInput
    away?: MatchingUncheckedUpdateManyWithoutUserAwayNestedInput
    rank?: UserTopRankingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
  }

  export type UserUpdateManyMutationInput = {
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
  }

  export type UserTopRankingsCreateInput = {
    rank: number
    mmr: number
    user: UserCreateNestedOneWithoutRankInput
  }

  export type UserTopRankingsUncheckedCreateInput = {
    userId: number
    rank: number
    mmr: number
  }

  export type UserTopRankingsUpdateInput = {
    rank?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutRankNestedInput
  }

  export type UserTopRankingsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
  }

  export type UserTopRankingsCreateManyInput = {
    userId: number
    rank: number
    mmr: number
  }

  export type UserTopRankingsUpdateManyMutationInput = {
    rank?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
  }

  export type UserTopRankingsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerCreateInput = {
    name: string
    speed: number
    passing: number
    dribbling: number
    heading: number
    shooting: number
    tackling: number
    marking: number
    strength: number
    weight: number
    nationality: string
    playerPool?: PlayerPoolCreateNestedManyWithoutPlayerIndexInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: number
    name: string
    speed: number
    passing: number
    dribbling: number
    heading: number
    shooting: number
    tackling: number
    marking: number
    strength: number
    weight: number
    nationality: string
    playerPool?: PlayerPoolUncheckedCreateNestedManyWithoutPlayerIndexInput
  }

  export type PlayerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    speed?: IntFieldUpdateOperationsInput | number
    passing?: IntFieldUpdateOperationsInput | number
    dribbling?: IntFieldUpdateOperationsInput | number
    heading?: IntFieldUpdateOperationsInput | number
    shooting?: IntFieldUpdateOperationsInput | number
    tackling?: IntFieldUpdateOperationsInput | number
    marking?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    playerPool?: PlayerPoolUpdateManyWithoutPlayerIndexNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    speed?: IntFieldUpdateOperationsInput | number
    passing?: IntFieldUpdateOperationsInput | number
    dribbling?: IntFieldUpdateOperationsInput | number
    heading?: IntFieldUpdateOperationsInput | number
    shooting?: IntFieldUpdateOperationsInput | number
    tackling?: IntFieldUpdateOperationsInput | number
    marking?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    playerPool?: PlayerPoolUncheckedUpdateManyWithoutPlayerIndexNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: number
    name: string
    speed: number
    passing: number
    dribbling: number
    heading: number
    shooting: number
    tackling: number
    marking: number
    strength: number
    weight: number
    nationality: string
  }

  export type PlayerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    speed?: IntFieldUpdateOperationsInput | number
    passing?: IntFieldUpdateOperationsInput | number
    dribbling?: IntFieldUpdateOperationsInput | number
    heading?: IntFieldUpdateOperationsInput | number
    shooting?: IntFieldUpdateOperationsInput | number
    tackling?: IntFieldUpdateOperationsInput | number
    marking?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    speed?: IntFieldUpdateOperationsInput | number
    passing?: IntFieldUpdateOperationsInput | number
    dribbling?: IntFieldUpdateOperationsInput | number
    heading?: IntFieldUpdateOperationsInput | number
    shooting?: IntFieldUpdateOperationsInput | number
    tackling?: IntFieldUpdateOperationsInput | number
    marking?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerPoolCreateInput = {
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
    user: UserCreateNestedOneWithoutPlayerPoolInput
    playerIndex: PlayerCreateNestedOneWithoutPlayerPoolInput
    squard?: SquardCreateNestedOneWithoutPlayerPoolInput
  }

  export type PlayerPoolUncheckedCreateInput = {
    id?: number
    userId: number
    playerId: number
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
    squard?: SquardUncheckedCreateNestedOneWithoutPlayerPoolInput
  }

  export type PlayerPoolUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutPlayerPoolNestedInput
    playerIndex?: PlayerUpdateOneRequiredWithoutPlayerPoolNestedInput
    squard?: SquardUpdateOneWithoutPlayerPoolNestedInput
  }

  export type PlayerPoolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
    squard?: SquardUncheckedUpdateOneWithoutPlayerPoolNestedInput
  }

  export type PlayerPoolCreateManyInput = {
    id?: number
    userId: number
    playerId: number
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
  }

  export type PlayerPoolUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerPoolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
  }

  export type SquardCreateInput = {
    playerPool: PlayerPoolCreateNestedOneWithoutSquardInput
    user: UserCreateNestedOneWithoutSquardInput
  }

  export type SquardUncheckedCreateInput = {
    id?: number
    userId: number
    playerPoolId: number
  }

  export type SquardUpdateInput = {
    playerPool?: PlayerPoolUpdateOneRequiredWithoutSquardNestedInput
    user?: UserUpdateOneRequiredWithoutSquardNestedInput
  }

  export type SquardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    playerPoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SquardCreateManyInput = {
    id?: number
    userId: number
    playerPoolId: number
  }

  export type SquardUpdateManyMutationInput = {

  }

  export type SquardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    playerPoolId?: IntFieldUpdateOperationsInput | number
  }

  export type MatchingCreateInput = {
    result: string
    userHome: UserCreateNestedOneWithoutHomeInput
    userAway: UserCreateNestedOneWithoutAwayInput
  }

  export type MatchingUncheckedCreateInput = {
    id?: number
    userHomeId: number
    userAwayId: number
    result: string
  }

  export type MatchingUpdateInput = {
    result?: StringFieldUpdateOperationsInput | string
    userHome?: UserUpdateOneRequiredWithoutHomeNestedInput
    userAway?: UserUpdateOneRequiredWithoutAwayNestedInput
  }

  export type MatchingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userHomeId?: IntFieldUpdateOperationsInput | number
    userAwayId?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
  }

  export type MatchingCreateManyInput = {
    id?: number
    userHomeId: number
    userAwayId: number
    result: string
  }

  export type MatchingUpdateManyMutationInput = {
    result?: StringFieldUpdateOperationsInput | string
  }

  export type MatchingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userHomeId?: IntFieldUpdateOperationsInput | number
    userAwayId?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PlayerPoolListRelationFilter = {
    every?: PlayerPoolWhereInput
    some?: PlayerPoolWhereInput
    none?: PlayerPoolWhereInput
  }

  export type SquardListRelationFilter = {
    every?: SquardWhereInput
    some?: SquardWhereInput
    none?: SquardWhereInput
  }

  export type MatchingListRelationFilter = {
    every?: MatchingWhereInput
    some?: MatchingWhereInput
    none?: MatchingWhereInput
  }

  export type UserTopRankingsNullableRelationFilter = {
    is?: UserTopRankingsWhereInput | null
    isNot?: UserTopRankingsWhereInput | null
  }

  export type PlayerPoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SquardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    accountName?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    cash?: SortOrder
    mmr?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    cash?: SortOrder
    mmr?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    accountName?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    cash?: SortOrder
    mmr?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    accountName?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    cash?: SortOrder
    mmr?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    cash?: SortOrder
    mmr?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserTopRankingsCountOrderByAggregateInput = {
    userId?: SortOrder
    rank?: SortOrder
    mmr?: SortOrder
  }

  export type UserTopRankingsAvgOrderByAggregateInput = {
    userId?: SortOrder
    rank?: SortOrder
    mmr?: SortOrder
  }

  export type UserTopRankingsMaxOrderByAggregateInput = {
    userId?: SortOrder
    rank?: SortOrder
    mmr?: SortOrder
  }

  export type UserTopRankingsMinOrderByAggregateInput = {
    userId?: SortOrder
    rank?: SortOrder
    mmr?: SortOrder
  }

  export type UserTopRankingsSumOrderByAggregateInput = {
    userId?: SortOrder
    rank?: SortOrder
    mmr?: SortOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    speed?: SortOrder
    passing?: SortOrder
    dribbling?: SortOrder
    heading?: SortOrder
    shooting?: SortOrder
    tackling?: SortOrder
    marking?: SortOrder
    strength?: SortOrder
    weight?: SortOrder
    nationality?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    id?: SortOrder
    speed?: SortOrder
    passing?: SortOrder
    dribbling?: SortOrder
    heading?: SortOrder
    shooting?: SortOrder
    tackling?: SortOrder
    marking?: SortOrder
    strength?: SortOrder
    weight?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    speed?: SortOrder
    passing?: SortOrder
    dribbling?: SortOrder
    heading?: SortOrder
    shooting?: SortOrder
    tackling?: SortOrder
    marking?: SortOrder
    strength?: SortOrder
    weight?: SortOrder
    nationality?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    speed?: SortOrder
    passing?: SortOrder
    dribbling?: SortOrder
    heading?: SortOrder
    shooting?: SortOrder
    tackling?: SortOrder
    marking?: SortOrder
    strength?: SortOrder
    weight?: SortOrder
    nationality?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    id?: SortOrder
    speed?: SortOrder
    passing?: SortOrder
    dribbling?: SortOrder
    heading?: SortOrder
    shooting?: SortOrder
    tackling?: SortOrder
    marking?: SortOrder
    strength?: SortOrder
    weight?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PlayerRelationFilter = {
    is?: PlayerWhereInput
    isNot?: PlayerWhereInput
  }

  export type SquardNullableRelationFilter = {
    is?: SquardWhereInput | null
    isNot?: SquardWhereInput | null
  }

  export type PlayerPoolCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    createdAt?: SortOrder
    playerLevel?: SortOrder
    playerName?: SortOrder
    count?: SortOrder
    sidelined?: SortOrder
    stamina?: SortOrder
  }

  export type PlayerPoolAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    playerLevel?: SortOrder
    count?: SortOrder
    stamina?: SortOrder
  }

  export type PlayerPoolMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    createdAt?: SortOrder
    playerLevel?: SortOrder
    playerName?: SortOrder
    count?: SortOrder
    sidelined?: SortOrder
    stamina?: SortOrder
  }

  export type PlayerPoolMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    createdAt?: SortOrder
    playerLevel?: SortOrder
    playerName?: SortOrder
    count?: SortOrder
    sidelined?: SortOrder
    stamina?: SortOrder
  }

  export type PlayerPoolSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    playerLevel?: SortOrder
    count?: SortOrder
    stamina?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PlayerPoolRelationFilter = {
    is?: PlayerPoolWhereInput
    isNot?: PlayerPoolWhereInput
  }

  export type SquardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    playerPoolId?: SortOrder
  }

  export type SquardAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    playerPoolId?: SortOrder
  }

  export type SquardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    playerPoolId?: SortOrder
  }

  export type SquardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    playerPoolId?: SortOrder
  }

  export type SquardSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    playerPoolId?: SortOrder
  }

  export type MatchingCountOrderByAggregateInput = {
    id?: SortOrder
    userHomeId?: SortOrder
    userAwayId?: SortOrder
    result?: SortOrder
  }

  export type MatchingAvgOrderByAggregateInput = {
    id?: SortOrder
    userHomeId?: SortOrder
    userAwayId?: SortOrder
  }

  export type MatchingMaxOrderByAggregateInput = {
    id?: SortOrder
    userHomeId?: SortOrder
    userAwayId?: SortOrder
    result?: SortOrder
  }

  export type MatchingMinOrderByAggregateInput = {
    id?: SortOrder
    userHomeId?: SortOrder
    userAwayId?: SortOrder
    result?: SortOrder
  }

  export type MatchingSumOrderByAggregateInput = {
    id?: SortOrder
    userHomeId?: SortOrder
    userAwayId?: SortOrder
  }

  export type PlayerPoolCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerPoolCreateWithoutUserInput, PlayerPoolUncheckedCreateWithoutUserInput> | PlayerPoolCreateWithoutUserInput[] | PlayerPoolUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerPoolCreateOrConnectWithoutUserInput | PlayerPoolCreateOrConnectWithoutUserInput[]
    createMany?: PlayerPoolCreateManyUserInputEnvelope
    connect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
  }

  export type SquardCreateNestedManyWithoutUserInput = {
    create?: XOR<SquardCreateWithoutUserInput, SquardUncheckedCreateWithoutUserInput> | SquardCreateWithoutUserInput[] | SquardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SquardCreateOrConnectWithoutUserInput | SquardCreateOrConnectWithoutUserInput[]
    createMany?: SquardCreateManyUserInputEnvelope
    connect?: SquardWhereUniqueInput | SquardWhereUniqueInput[]
  }

  export type MatchingCreateNestedManyWithoutUserHomeInput = {
    create?: XOR<MatchingCreateWithoutUserHomeInput, MatchingUncheckedCreateWithoutUserHomeInput> | MatchingCreateWithoutUserHomeInput[] | MatchingUncheckedCreateWithoutUserHomeInput[]
    connectOrCreate?: MatchingCreateOrConnectWithoutUserHomeInput | MatchingCreateOrConnectWithoutUserHomeInput[]
    createMany?: MatchingCreateManyUserHomeInputEnvelope
    connect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
  }

  export type MatchingCreateNestedManyWithoutUserAwayInput = {
    create?: XOR<MatchingCreateWithoutUserAwayInput, MatchingUncheckedCreateWithoutUserAwayInput> | MatchingCreateWithoutUserAwayInput[] | MatchingUncheckedCreateWithoutUserAwayInput[]
    connectOrCreate?: MatchingCreateOrConnectWithoutUserAwayInput | MatchingCreateOrConnectWithoutUserAwayInput[]
    createMany?: MatchingCreateManyUserAwayInputEnvelope
    connect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
  }

  export type UserTopRankingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserTopRankingsCreateWithoutUserInput, UserTopRankingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserTopRankingsCreateOrConnectWithoutUserInput
    connect?: UserTopRankingsWhereUniqueInput
  }

  export type PlayerPoolUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerPoolCreateWithoutUserInput, PlayerPoolUncheckedCreateWithoutUserInput> | PlayerPoolCreateWithoutUserInput[] | PlayerPoolUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerPoolCreateOrConnectWithoutUserInput | PlayerPoolCreateOrConnectWithoutUserInput[]
    createMany?: PlayerPoolCreateManyUserInputEnvelope
    connect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
  }

  export type SquardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SquardCreateWithoutUserInput, SquardUncheckedCreateWithoutUserInput> | SquardCreateWithoutUserInput[] | SquardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SquardCreateOrConnectWithoutUserInput | SquardCreateOrConnectWithoutUserInput[]
    createMany?: SquardCreateManyUserInputEnvelope
    connect?: SquardWhereUniqueInput | SquardWhereUniqueInput[]
  }

  export type MatchingUncheckedCreateNestedManyWithoutUserHomeInput = {
    create?: XOR<MatchingCreateWithoutUserHomeInput, MatchingUncheckedCreateWithoutUserHomeInput> | MatchingCreateWithoutUserHomeInput[] | MatchingUncheckedCreateWithoutUserHomeInput[]
    connectOrCreate?: MatchingCreateOrConnectWithoutUserHomeInput | MatchingCreateOrConnectWithoutUserHomeInput[]
    createMany?: MatchingCreateManyUserHomeInputEnvelope
    connect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
  }

  export type MatchingUncheckedCreateNestedManyWithoutUserAwayInput = {
    create?: XOR<MatchingCreateWithoutUserAwayInput, MatchingUncheckedCreateWithoutUserAwayInput> | MatchingCreateWithoutUserAwayInput[] | MatchingUncheckedCreateWithoutUserAwayInput[]
    connectOrCreate?: MatchingCreateOrConnectWithoutUserAwayInput | MatchingCreateOrConnectWithoutUserAwayInput[]
    createMany?: MatchingCreateManyUserAwayInputEnvelope
    connect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
  }

  export type UserTopRankingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserTopRankingsCreateWithoutUserInput, UserTopRankingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserTopRankingsCreateOrConnectWithoutUserInput
    connect?: UserTopRankingsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlayerPoolUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerPoolCreateWithoutUserInput, PlayerPoolUncheckedCreateWithoutUserInput> | PlayerPoolCreateWithoutUserInput[] | PlayerPoolUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerPoolCreateOrConnectWithoutUserInput | PlayerPoolCreateOrConnectWithoutUserInput[]
    upsert?: PlayerPoolUpsertWithWhereUniqueWithoutUserInput | PlayerPoolUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerPoolCreateManyUserInputEnvelope
    set?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    disconnect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    delete?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    connect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    update?: PlayerPoolUpdateWithWhereUniqueWithoutUserInput | PlayerPoolUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerPoolUpdateManyWithWhereWithoutUserInput | PlayerPoolUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerPoolScalarWhereInput | PlayerPoolScalarWhereInput[]
  }

  export type SquardUpdateManyWithoutUserNestedInput = {
    create?: XOR<SquardCreateWithoutUserInput, SquardUncheckedCreateWithoutUserInput> | SquardCreateWithoutUserInput[] | SquardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SquardCreateOrConnectWithoutUserInput | SquardCreateOrConnectWithoutUserInput[]
    upsert?: SquardUpsertWithWhereUniqueWithoutUserInput | SquardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SquardCreateManyUserInputEnvelope
    set?: SquardWhereUniqueInput | SquardWhereUniqueInput[]
    disconnect?: SquardWhereUniqueInput | SquardWhereUniqueInput[]
    delete?: SquardWhereUniqueInput | SquardWhereUniqueInput[]
    connect?: SquardWhereUniqueInput | SquardWhereUniqueInput[]
    update?: SquardUpdateWithWhereUniqueWithoutUserInput | SquardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SquardUpdateManyWithWhereWithoutUserInput | SquardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SquardScalarWhereInput | SquardScalarWhereInput[]
  }

  export type MatchingUpdateManyWithoutUserHomeNestedInput = {
    create?: XOR<MatchingCreateWithoutUserHomeInput, MatchingUncheckedCreateWithoutUserHomeInput> | MatchingCreateWithoutUserHomeInput[] | MatchingUncheckedCreateWithoutUserHomeInput[]
    connectOrCreate?: MatchingCreateOrConnectWithoutUserHomeInput | MatchingCreateOrConnectWithoutUserHomeInput[]
    upsert?: MatchingUpsertWithWhereUniqueWithoutUserHomeInput | MatchingUpsertWithWhereUniqueWithoutUserHomeInput[]
    createMany?: MatchingCreateManyUserHomeInputEnvelope
    set?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    disconnect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    delete?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    connect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    update?: MatchingUpdateWithWhereUniqueWithoutUserHomeInput | MatchingUpdateWithWhereUniqueWithoutUserHomeInput[]
    updateMany?: MatchingUpdateManyWithWhereWithoutUserHomeInput | MatchingUpdateManyWithWhereWithoutUserHomeInput[]
    deleteMany?: MatchingScalarWhereInput | MatchingScalarWhereInput[]
  }

  export type MatchingUpdateManyWithoutUserAwayNestedInput = {
    create?: XOR<MatchingCreateWithoutUserAwayInput, MatchingUncheckedCreateWithoutUserAwayInput> | MatchingCreateWithoutUserAwayInput[] | MatchingUncheckedCreateWithoutUserAwayInput[]
    connectOrCreate?: MatchingCreateOrConnectWithoutUserAwayInput | MatchingCreateOrConnectWithoutUserAwayInput[]
    upsert?: MatchingUpsertWithWhereUniqueWithoutUserAwayInput | MatchingUpsertWithWhereUniqueWithoutUserAwayInput[]
    createMany?: MatchingCreateManyUserAwayInputEnvelope
    set?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    disconnect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    delete?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    connect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    update?: MatchingUpdateWithWhereUniqueWithoutUserAwayInput | MatchingUpdateWithWhereUniqueWithoutUserAwayInput[]
    updateMany?: MatchingUpdateManyWithWhereWithoutUserAwayInput | MatchingUpdateManyWithWhereWithoutUserAwayInput[]
    deleteMany?: MatchingScalarWhereInput | MatchingScalarWhereInput[]
  }

  export type UserTopRankingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserTopRankingsCreateWithoutUserInput, UserTopRankingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserTopRankingsCreateOrConnectWithoutUserInput
    upsert?: UserTopRankingsUpsertWithoutUserInput
    disconnect?: UserTopRankingsWhereInput | boolean
    delete?: UserTopRankingsWhereInput | boolean
    connect?: UserTopRankingsWhereUniqueInput
    update?: XOR<XOR<UserTopRankingsUpdateToOneWithWhereWithoutUserInput, UserTopRankingsUpdateWithoutUserInput>, UserTopRankingsUncheckedUpdateWithoutUserInput>
  }

  export type PlayerPoolUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerPoolCreateWithoutUserInput, PlayerPoolUncheckedCreateWithoutUserInput> | PlayerPoolCreateWithoutUserInput[] | PlayerPoolUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerPoolCreateOrConnectWithoutUserInput | PlayerPoolCreateOrConnectWithoutUserInput[]
    upsert?: PlayerPoolUpsertWithWhereUniqueWithoutUserInput | PlayerPoolUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerPoolCreateManyUserInputEnvelope
    set?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    disconnect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    delete?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    connect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    update?: PlayerPoolUpdateWithWhereUniqueWithoutUserInput | PlayerPoolUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerPoolUpdateManyWithWhereWithoutUserInput | PlayerPoolUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerPoolScalarWhereInput | PlayerPoolScalarWhereInput[]
  }

  export type SquardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SquardCreateWithoutUserInput, SquardUncheckedCreateWithoutUserInput> | SquardCreateWithoutUserInput[] | SquardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SquardCreateOrConnectWithoutUserInput | SquardCreateOrConnectWithoutUserInput[]
    upsert?: SquardUpsertWithWhereUniqueWithoutUserInput | SquardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SquardCreateManyUserInputEnvelope
    set?: SquardWhereUniqueInput | SquardWhereUniqueInput[]
    disconnect?: SquardWhereUniqueInput | SquardWhereUniqueInput[]
    delete?: SquardWhereUniqueInput | SquardWhereUniqueInput[]
    connect?: SquardWhereUniqueInput | SquardWhereUniqueInput[]
    update?: SquardUpdateWithWhereUniqueWithoutUserInput | SquardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SquardUpdateManyWithWhereWithoutUserInput | SquardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SquardScalarWhereInput | SquardScalarWhereInput[]
  }

  export type MatchingUncheckedUpdateManyWithoutUserHomeNestedInput = {
    create?: XOR<MatchingCreateWithoutUserHomeInput, MatchingUncheckedCreateWithoutUserHomeInput> | MatchingCreateWithoutUserHomeInput[] | MatchingUncheckedCreateWithoutUserHomeInput[]
    connectOrCreate?: MatchingCreateOrConnectWithoutUserHomeInput | MatchingCreateOrConnectWithoutUserHomeInput[]
    upsert?: MatchingUpsertWithWhereUniqueWithoutUserHomeInput | MatchingUpsertWithWhereUniqueWithoutUserHomeInput[]
    createMany?: MatchingCreateManyUserHomeInputEnvelope
    set?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    disconnect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    delete?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    connect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    update?: MatchingUpdateWithWhereUniqueWithoutUserHomeInput | MatchingUpdateWithWhereUniqueWithoutUserHomeInput[]
    updateMany?: MatchingUpdateManyWithWhereWithoutUserHomeInput | MatchingUpdateManyWithWhereWithoutUserHomeInput[]
    deleteMany?: MatchingScalarWhereInput | MatchingScalarWhereInput[]
  }

  export type MatchingUncheckedUpdateManyWithoutUserAwayNestedInput = {
    create?: XOR<MatchingCreateWithoutUserAwayInput, MatchingUncheckedCreateWithoutUserAwayInput> | MatchingCreateWithoutUserAwayInput[] | MatchingUncheckedCreateWithoutUserAwayInput[]
    connectOrCreate?: MatchingCreateOrConnectWithoutUserAwayInput | MatchingCreateOrConnectWithoutUserAwayInput[]
    upsert?: MatchingUpsertWithWhereUniqueWithoutUserAwayInput | MatchingUpsertWithWhereUniqueWithoutUserAwayInput[]
    createMany?: MatchingCreateManyUserAwayInputEnvelope
    set?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    disconnect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    delete?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    connect?: MatchingWhereUniqueInput | MatchingWhereUniqueInput[]
    update?: MatchingUpdateWithWhereUniqueWithoutUserAwayInput | MatchingUpdateWithWhereUniqueWithoutUserAwayInput[]
    updateMany?: MatchingUpdateManyWithWhereWithoutUserAwayInput | MatchingUpdateManyWithWhereWithoutUserAwayInput[]
    deleteMany?: MatchingScalarWhereInput | MatchingScalarWhereInput[]
  }

  export type UserTopRankingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserTopRankingsCreateWithoutUserInput, UserTopRankingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserTopRankingsCreateOrConnectWithoutUserInput
    upsert?: UserTopRankingsUpsertWithoutUserInput
    disconnect?: UserTopRankingsWhereInput | boolean
    delete?: UserTopRankingsWhereInput | boolean
    connect?: UserTopRankingsWhereUniqueInput
    update?: XOR<XOR<UserTopRankingsUpdateToOneWithWhereWithoutUserInput, UserTopRankingsUpdateWithoutUserInput>, UserTopRankingsUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutRankInput = {
    create?: XOR<UserCreateWithoutRankInput, UserUncheckedCreateWithoutRankInput>
    connectOrCreate?: UserCreateOrConnectWithoutRankInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRankNestedInput = {
    create?: XOR<UserCreateWithoutRankInput, UserUncheckedCreateWithoutRankInput>
    connectOrCreate?: UserCreateOrConnectWithoutRankInput
    upsert?: UserUpsertWithoutRankInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRankInput, UserUpdateWithoutRankInput>, UserUncheckedUpdateWithoutRankInput>
  }

  export type PlayerPoolCreateNestedManyWithoutPlayerIndexInput = {
    create?: XOR<PlayerPoolCreateWithoutPlayerIndexInput, PlayerPoolUncheckedCreateWithoutPlayerIndexInput> | PlayerPoolCreateWithoutPlayerIndexInput[] | PlayerPoolUncheckedCreateWithoutPlayerIndexInput[]
    connectOrCreate?: PlayerPoolCreateOrConnectWithoutPlayerIndexInput | PlayerPoolCreateOrConnectWithoutPlayerIndexInput[]
    createMany?: PlayerPoolCreateManyPlayerIndexInputEnvelope
    connect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
  }

  export type PlayerPoolUncheckedCreateNestedManyWithoutPlayerIndexInput = {
    create?: XOR<PlayerPoolCreateWithoutPlayerIndexInput, PlayerPoolUncheckedCreateWithoutPlayerIndexInput> | PlayerPoolCreateWithoutPlayerIndexInput[] | PlayerPoolUncheckedCreateWithoutPlayerIndexInput[]
    connectOrCreate?: PlayerPoolCreateOrConnectWithoutPlayerIndexInput | PlayerPoolCreateOrConnectWithoutPlayerIndexInput[]
    createMany?: PlayerPoolCreateManyPlayerIndexInputEnvelope
    connect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
  }

  export type PlayerPoolUpdateManyWithoutPlayerIndexNestedInput = {
    create?: XOR<PlayerPoolCreateWithoutPlayerIndexInput, PlayerPoolUncheckedCreateWithoutPlayerIndexInput> | PlayerPoolCreateWithoutPlayerIndexInput[] | PlayerPoolUncheckedCreateWithoutPlayerIndexInput[]
    connectOrCreate?: PlayerPoolCreateOrConnectWithoutPlayerIndexInput | PlayerPoolCreateOrConnectWithoutPlayerIndexInput[]
    upsert?: PlayerPoolUpsertWithWhereUniqueWithoutPlayerIndexInput | PlayerPoolUpsertWithWhereUniqueWithoutPlayerIndexInput[]
    createMany?: PlayerPoolCreateManyPlayerIndexInputEnvelope
    set?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    disconnect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    delete?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    connect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    update?: PlayerPoolUpdateWithWhereUniqueWithoutPlayerIndexInput | PlayerPoolUpdateWithWhereUniqueWithoutPlayerIndexInput[]
    updateMany?: PlayerPoolUpdateManyWithWhereWithoutPlayerIndexInput | PlayerPoolUpdateManyWithWhereWithoutPlayerIndexInput[]
    deleteMany?: PlayerPoolScalarWhereInput | PlayerPoolScalarWhereInput[]
  }

  export type PlayerPoolUncheckedUpdateManyWithoutPlayerIndexNestedInput = {
    create?: XOR<PlayerPoolCreateWithoutPlayerIndexInput, PlayerPoolUncheckedCreateWithoutPlayerIndexInput> | PlayerPoolCreateWithoutPlayerIndexInput[] | PlayerPoolUncheckedCreateWithoutPlayerIndexInput[]
    connectOrCreate?: PlayerPoolCreateOrConnectWithoutPlayerIndexInput | PlayerPoolCreateOrConnectWithoutPlayerIndexInput[]
    upsert?: PlayerPoolUpsertWithWhereUniqueWithoutPlayerIndexInput | PlayerPoolUpsertWithWhereUniqueWithoutPlayerIndexInput[]
    createMany?: PlayerPoolCreateManyPlayerIndexInputEnvelope
    set?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    disconnect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    delete?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    connect?: PlayerPoolWhereUniqueInput | PlayerPoolWhereUniqueInput[]
    update?: PlayerPoolUpdateWithWhereUniqueWithoutPlayerIndexInput | PlayerPoolUpdateWithWhereUniqueWithoutPlayerIndexInput[]
    updateMany?: PlayerPoolUpdateManyWithWhereWithoutPlayerIndexInput | PlayerPoolUpdateManyWithWhereWithoutPlayerIndexInput[]
    deleteMany?: PlayerPoolScalarWhereInput | PlayerPoolScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPlayerPoolInput = {
    create?: XOR<UserCreateWithoutPlayerPoolInput, UserUncheckedCreateWithoutPlayerPoolInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerPoolInput
    connect?: UserWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutPlayerPoolInput = {
    create?: XOR<PlayerCreateWithoutPlayerPoolInput, PlayerUncheckedCreateWithoutPlayerPoolInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayerPoolInput
    connect?: PlayerWhereUniqueInput
  }

  export type SquardCreateNestedOneWithoutPlayerPoolInput = {
    create?: XOR<SquardCreateWithoutPlayerPoolInput, SquardUncheckedCreateWithoutPlayerPoolInput>
    connectOrCreate?: SquardCreateOrConnectWithoutPlayerPoolInput
    connect?: SquardWhereUniqueInput
  }

  export type SquardUncheckedCreateNestedOneWithoutPlayerPoolInput = {
    create?: XOR<SquardCreateWithoutPlayerPoolInput, SquardUncheckedCreateWithoutPlayerPoolInput>
    connectOrCreate?: SquardCreateOrConnectWithoutPlayerPoolInput
    connect?: SquardWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutPlayerPoolNestedInput = {
    create?: XOR<UserCreateWithoutPlayerPoolInput, UserUncheckedCreateWithoutPlayerPoolInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerPoolInput
    upsert?: UserUpsertWithoutPlayerPoolInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayerPoolInput, UserUpdateWithoutPlayerPoolInput>, UserUncheckedUpdateWithoutPlayerPoolInput>
  }

  export type PlayerUpdateOneRequiredWithoutPlayerPoolNestedInput = {
    create?: XOR<PlayerCreateWithoutPlayerPoolInput, PlayerUncheckedCreateWithoutPlayerPoolInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayerPoolInput
    upsert?: PlayerUpsertWithoutPlayerPoolInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutPlayerPoolInput, PlayerUpdateWithoutPlayerPoolInput>, PlayerUncheckedUpdateWithoutPlayerPoolInput>
  }

  export type SquardUpdateOneWithoutPlayerPoolNestedInput = {
    create?: XOR<SquardCreateWithoutPlayerPoolInput, SquardUncheckedCreateWithoutPlayerPoolInput>
    connectOrCreate?: SquardCreateOrConnectWithoutPlayerPoolInput
    upsert?: SquardUpsertWithoutPlayerPoolInput
    disconnect?: SquardWhereInput | boolean
    delete?: SquardWhereInput | boolean
    connect?: SquardWhereUniqueInput
    update?: XOR<XOR<SquardUpdateToOneWithWhereWithoutPlayerPoolInput, SquardUpdateWithoutPlayerPoolInput>, SquardUncheckedUpdateWithoutPlayerPoolInput>
  }

  export type SquardUncheckedUpdateOneWithoutPlayerPoolNestedInput = {
    create?: XOR<SquardCreateWithoutPlayerPoolInput, SquardUncheckedCreateWithoutPlayerPoolInput>
    connectOrCreate?: SquardCreateOrConnectWithoutPlayerPoolInput
    upsert?: SquardUpsertWithoutPlayerPoolInput
    disconnect?: SquardWhereInput | boolean
    delete?: SquardWhereInput | boolean
    connect?: SquardWhereUniqueInput
    update?: XOR<XOR<SquardUpdateToOneWithWhereWithoutPlayerPoolInput, SquardUpdateWithoutPlayerPoolInput>, SquardUncheckedUpdateWithoutPlayerPoolInput>
  }

  export type PlayerPoolCreateNestedOneWithoutSquardInput = {
    create?: XOR<PlayerPoolCreateWithoutSquardInput, PlayerPoolUncheckedCreateWithoutSquardInput>
    connectOrCreate?: PlayerPoolCreateOrConnectWithoutSquardInput
    connect?: PlayerPoolWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSquardInput = {
    create?: XOR<UserCreateWithoutSquardInput, UserUncheckedCreateWithoutSquardInput>
    connectOrCreate?: UserCreateOrConnectWithoutSquardInput
    connect?: UserWhereUniqueInput
  }

  export type PlayerPoolUpdateOneRequiredWithoutSquardNestedInput = {
    create?: XOR<PlayerPoolCreateWithoutSquardInput, PlayerPoolUncheckedCreateWithoutSquardInput>
    connectOrCreate?: PlayerPoolCreateOrConnectWithoutSquardInput
    upsert?: PlayerPoolUpsertWithoutSquardInput
    connect?: PlayerPoolWhereUniqueInput
    update?: XOR<XOR<PlayerPoolUpdateToOneWithWhereWithoutSquardInput, PlayerPoolUpdateWithoutSquardInput>, PlayerPoolUncheckedUpdateWithoutSquardInput>
  }

  export type UserUpdateOneRequiredWithoutSquardNestedInput = {
    create?: XOR<UserCreateWithoutSquardInput, UserUncheckedCreateWithoutSquardInput>
    connectOrCreate?: UserCreateOrConnectWithoutSquardInput
    upsert?: UserUpsertWithoutSquardInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSquardInput, UserUpdateWithoutSquardInput>, UserUncheckedUpdateWithoutSquardInput>
  }

  export type UserCreateNestedOneWithoutHomeInput = {
    create?: XOR<UserCreateWithoutHomeInput, UserUncheckedCreateWithoutHomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutHomeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAwayInput = {
    create?: XOR<UserCreateWithoutAwayInput, UserUncheckedCreateWithoutAwayInput>
    connectOrCreate?: UserCreateOrConnectWithoutAwayInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutHomeNestedInput = {
    create?: XOR<UserCreateWithoutHomeInput, UserUncheckedCreateWithoutHomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutHomeInput
    upsert?: UserUpsertWithoutHomeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHomeInput, UserUpdateWithoutHomeInput>, UserUncheckedUpdateWithoutHomeInput>
  }

  export type UserUpdateOneRequiredWithoutAwayNestedInput = {
    create?: XOR<UserCreateWithoutAwayInput, UserUncheckedCreateWithoutAwayInput>
    connectOrCreate?: UserCreateOrConnectWithoutAwayInput
    upsert?: UserUpsertWithoutAwayInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAwayInput, UserUpdateWithoutAwayInput>, UserUncheckedUpdateWithoutAwayInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PlayerPoolCreateWithoutUserInput = {
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
    playerIndex: PlayerCreateNestedOneWithoutPlayerPoolInput
    squard?: SquardCreateNestedOneWithoutPlayerPoolInput
  }

  export type PlayerPoolUncheckedCreateWithoutUserInput = {
    id?: number
    playerId: number
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
    squard?: SquardUncheckedCreateNestedOneWithoutPlayerPoolInput
  }

  export type PlayerPoolCreateOrConnectWithoutUserInput = {
    where: PlayerPoolWhereUniqueInput
    create: XOR<PlayerPoolCreateWithoutUserInput, PlayerPoolUncheckedCreateWithoutUserInput>
  }

  export type PlayerPoolCreateManyUserInputEnvelope = {
    data: PlayerPoolCreateManyUserInput | PlayerPoolCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SquardCreateWithoutUserInput = {
    playerPool: PlayerPoolCreateNestedOneWithoutSquardInput
  }

  export type SquardUncheckedCreateWithoutUserInput = {
    id?: number
    playerPoolId: number
  }

  export type SquardCreateOrConnectWithoutUserInput = {
    where: SquardWhereUniqueInput
    create: XOR<SquardCreateWithoutUserInput, SquardUncheckedCreateWithoutUserInput>
  }

  export type SquardCreateManyUserInputEnvelope = {
    data: SquardCreateManyUserInput | SquardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MatchingCreateWithoutUserHomeInput = {
    result: string
    userAway: UserCreateNestedOneWithoutAwayInput
  }

  export type MatchingUncheckedCreateWithoutUserHomeInput = {
    id?: number
    userAwayId: number
    result: string
  }

  export type MatchingCreateOrConnectWithoutUserHomeInput = {
    where: MatchingWhereUniqueInput
    create: XOR<MatchingCreateWithoutUserHomeInput, MatchingUncheckedCreateWithoutUserHomeInput>
  }

  export type MatchingCreateManyUserHomeInputEnvelope = {
    data: MatchingCreateManyUserHomeInput | MatchingCreateManyUserHomeInput[]
    skipDuplicates?: boolean
  }

  export type MatchingCreateWithoutUserAwayInput = {
    result: string
    userHome: UserCreateNestedOneWithoutHomeInput
  }

  export type MatchingUncheckedCreateWithoutUserAwayInput = {
    id?: number
    userHomeId: number
    result: string
  }

  export type MatchingCreateOrConnectWithoutUserAwayInput = {
    where: MatchingWhereUniqueInput
    create: XOR<MatchingCreateWithoutUserAwayInput, MatchingUncheckedCreateWithoutUserAwayInput>
  }

  export type MatchingCreateManyUserAwayInputEnvelope = {
    data: MatchingCreateManyUserAwayInput | MatchingCreateManyUserAwayInput[]
    skipDuplicates?: boolean
  }

  export type UserTopRankingsCreateWithoutUserInput = {
    rank: number
    mmr: number
  }

  export type UserTopRankingsUncheckedCreateWithoutUserInput = {
    rank: number
    mmr: number
  }

  export type UserTopRankingsCreateOrConnectWithoutUserInput = {
    where: UserTopRankingsWhereUniqueInput
    create: XOR<UserTopRankingsCreateWithoutUserInput, UserTopRankingsUncheckedCreateWithoutUserInput>
  }

  export type PlayerPoolUpsertWithWhereUniqueWithoutUserInput = {
    where: PlayerPoolWhereUniqueInput
    update: XOR<PlayerPoolUpdateWithoutUserInput, PlayerPoolUncheckedUpdateWithoutUserInput>
    create: XOR<PlayerPoolCreateWithoutUserInput, PlayerPoolUncheckedCreateWithoutUserInput>
  }

  export type PlayerPoolUpdateWithWhereUniqueWithoutUserInput = {
    where: PlayerPoolWhereUniqueInput
    data: XOR<PlayerPoolUpdateWithoutUserInput, PlayerPoolUncheckedUpdateWithoutUserInput>
  }

  export type PlayerPoolUpdateManyWithWhereWithoutUserInput = {
    where: PlayerPoolScalarWhereInput
    data: XOR<PlayerPoolUpdateManyMutationInput, PlayerPoolUncheckedUpdateManyWithoutUserInput>
  }

  export type PlayerPoolScalarWhereInput = {
    AND?: PlayerPoolScalarWhereInput | PlayerPoolScalarWhereInput[]
    OR?: PlayerPoolScalarWhereInput[]
    NOT?: PlayerPoolScalarWhereInput | PlayerPoolScalarWhereInput[]
    id?: IntFilter<"PlayerPool"> | number
    userId?: IntFilter<"PlayerPool"> | number
    playerId?: IntFilter<"PlayerPool"> | number
    createdAt?: DateTimeFilter<"PlayerPool"> | Date | string
    playerLevel?: IntFilter<"PlayerPool"> | number
    playerName?: StringFilter<"PlayerPool"> | string
    count?: IntFilter<"PlayerPool"> | number
    sidelined?: BoolFilter<"PlayerPool"> | boolean
    stamina?: IntFilter<"PlayerPool"> | number
  }

  export type SquardUpsertWithWhereUniqueWithoutUserInput = {
    where: SquardWhereUniqueInput
    update: XOR<SquardUpdateWithoutUserInput, SquardUncheckedUpdateWithoutUserInput>
    create: XOR<SquardCreateWithoutUserInput, SquardUncheckedCreateWithoutUserInput>
  }

  export type SquardUpdateWithWhereUniqueWithoutUserInput = {
    where: SquardWhereUniqueInput
    data: XOR<SquardUpdateWithoutUserInput, SquardUncheckedUpdateWithoutUserInput>
  }

  export type SquardUpdateManyWithWhereWithoutUserInput = {
    where: SquardScalarWhereInput
    data: XOR<SquardUpdateManyMutationInput, SquardUncheckedUpdateManyWithoutUserInput>
  }

  export type SquardScalarWhereInput = {
    AND?: SquardScalarWhereInput | SquardScalarWhereInput[]
    OR?: SquardScalarWhereInput[]
    NOT?: SquardScalarWhereInput | SquardScalarWhereInput[]
    id?: IntFilter<"Squard"> | number
    userId?: IntFilter<"Squard"> | number
    playerPoolId?: IntFilter<"Squard"> | number
  }

  export type MatchingUpsertWithWhereUniqueWithoutUserHomeInput = {
    where: MatchingWhereUniqueInput
    update: XOR<MatchingUpdateWithoutUserHomeInput, MatchingUncheckedUpdateWithoutUserHomeInput>
    create: XOR<MatchingCreateWithoutUserHomeInput, MatchingUncheckedCreateWithoutUserHomeInput>
  }

  export type MatchingUpdateWithWhereUniqueWithoutUserHomeInput = {
    where: MatchingWhereUniqueInput
    data: XOR<MatchingUpdateWithoutUserHomeInput, MatchingUncheckedUpdateWithoutUserHomeInput>
  }

  export type MatchingUpdateManyWithWhereWithoutUserHomeInput = {
    where: MatchingScalarWhereInput
    data: XOR<MatchingUpdateManyMutationInput, MatchingUncheckedUpdateManyWithoutUserHomeInput>
  }

  export type MatchingScalarWhereInput = {
    AND?: MatchingScalarWhereInput | MatchingScalarWhereInput[]
    OR?: MatchingScalarWhereInput[]
    NOT?: MatchingScalarWhereInput | MatchingScalarWhereInput[]
    id?: IntFilter<"Matching"> | number
    userHomeId?: IntFilter<"Matching"> | number
    userAwayId?: IntFilter<"Matching"> | number
    result?: StringFilter<"Matching"> | string
  }

  export type MatchingUpsertWithWhereUniqueWithoutUserAwayInput = {
    where: MatchingWhereUniqueInput
    update: XOR<MatchingUpdateWithoutUserAwayInput, MatchingUncheckedUpdateWithoutUserAwayInput>
    create: XOR<MatchingCreateWithoutUserAwayInput, MatchingUncheckedCreateWithoutUserAwayInput>
  }

  export type MatchingUpdateWithWhereUniqueWithoutUserAwayInput = {
    where: MatchingWhereUniqueInput
    data: XOR<MatchingUpdateWithoutUserAwayInput, MatchingUncheckedUpdateWithoutUserAwayInput>
  }

  export type MatchingUpdateManyWithWhereWithoutUserAwayInput = {
    where: MatchingScalarWhereInput
    data: XOR<MatchingUpdateManyMutationInput, MatchingUncheckedUpdateManyWithoutUserAwayInput>
  }

  export type UserTopRankingsUpsertWithoutUserInput = {
    update: XOR<UserTopRankingsUpdateWithoutUserInput, UserTopRankingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserTopRankingsCreateWithoutUserInput, UserTopRankingsUncheckedCreateWithoutUserInput>
    where?: UserTopRankingsWhereInput
  }

  export type UserTopRankingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserTopRankingsWhereInput
    data: XOR<UserTopRankingsUpdateWithoutUserInput, UserTopRankingsUncheckedUpdateWithoutUserInput>
  }

  export type UserTopRankingsUpdateWithoutUserInput = {
    rank?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
  }

  export type UserTopRankingsUncheckedUpdateWithoutUserInput = {
    rank?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutRankInput = {
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    playerPool?: PlayerPoolCreateNestedManyWithoutUserInput
    squard?: SquardCreateNestedManyWithoutUserInput
    home?: MatchingCreateNestedManyWithoutUserHomeInput
    away?: MatchingCreateNestedManyWithoutUserAwayInput
  }

  export type UserUncheckedCreateWithoutRankInput = {
    id?: number
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    playerPool?: PlayerPoolUncheckedCreateNestedManyWithoutUserInput
    squard?: SquardUncheckedCreateNestedManyWithoutUserInput
    home?: MatchingUncheckedCreateNestedManyWithoutUserHomeInput
    away?: MatchingUncheckedCreateNestedManyWithoutUserAwayInput
  }

  export type UserCreateOrConnectWithoutRankInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRankInput, UserUncheckedCreateWithoutRankInput>
  }

  export type UserUpsertWithoutRankInput = {
    update: XOR<UserUpdateWithoutRankInput, UserUncheckedUpdateWithoutRankInput>
    create: XOR<UserCreateWithoutRankInput, UserUncheckedCreateWithoutRankInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRankInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRankInput, UserUncheckedUpdateWithoutRankInput>
  }

  export type UserUpdateWithoutRankInput = {
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    playerPool?: PlayerPoolUpdateManyWithoutUserNestedInput
    squard?: SquardUpdateManyWithoutUserNestedInput
    home?: MatchingUpdateManyWithoutUserHomeNestedInput
    away?: MatchingUpdateManyWithoutUserAwayNestedInput
  }

  export type UserUncheckedUpdateWithoutRankInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    playerPool?: PlayerPoolUncheckedUpdateManyWithoutUserNestedInput
    squard?: SquardUncheckedUpdateManyWithoutUserNestedInput
    home?: MatchingUncheckedUpdateManyWithoutUserHomeNestedInput
    away?: MatchingUncheckedUpdateManyWithoutUserAwayNestedInput
  }

  export type PlayerPoolCreateWithoutPlayerIndexInput = {
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
    user: UserCreateNestedOneWithoutPlayerPoolInput
    squard?: SquardCreateNestedOneWithoutPlayerPoolInput
  }

  export type PlayerPoolUncheckedCreateWithoutPlayerIndexInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
    squard?: SquardUncheckedCreateNestedOneWithoutPlayerPoolInput
  }

  export type PlayerPoolCreateOrConnectWithoutPlayerIndexInput = {
    where: PlayerPoolWhereUniqueInput
    create: XOR<PlayerPoolCreateWithoutPlayerIndexInput, PlayerPoolUncheckedCreateWithoutPlayerIndexInput>
  }

  export type PlayerPoolCreateManyPlayerIndexInputEnvelope = {
    data: PlayerPoolCreateManyPlayerIndexInput | PlayerPoolCreateManyPlayerIndexInput[]
    skipDuplicates?: boolean
  }

  export type PlayerPoolUpsertWithWhereUniqueWithoutPlayerIndexInput = {
    where: PlayerPoolWhereUniqueInput
    update: XOR<PlayerPoolUpdateWithoutPlayerIndexInput, PlayerPoolUncheckedUpdateWithoutPlayerIndexInput>
    create: XOR<PlayerPoolCreateWithoutPlayerIndexInput, PlayerPoolUncheckedCreateWithoutPlayerIndexInput>
  }

  export type PlayerPoolUpdateWithWhereUniqueWithoutPlayerIndexInput = {
    where: PlayerPoolWhereUniqueInput
    data: XOR<PlayerPoolUpdateWithoutPlayerIndexInput, PlayerPoolUncheckedUpdateWithoutPlayerIndexInput>
  }

  export type PlayerPoolUpdateManyWithWhereWithoutPlayerIndexInput = {
    where: PlayerPoolScalarWhereInput
    data: XOR<PlayerPoolUpdateManyMutationInput, PlayerPoolUncheckedUpdateManyWithoutPlayerIndexInput>
  }

  export type UserCreateWithoutPlayerPoolInput = {
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    squard?: SquardCreateNestedManyWithoutUserInput
    home?: MatchingCreateNestedManyWithoutUserHomeInput
    away?: MatchingCreateNestedManyWithoutUserAwayInput
    rank?: UserTopRankingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlayerPoolInput = {
    id?: number
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    squard?: SquardUncheckedCreateNestedManyWithoutUserInput
    home?: MatchingUncheckedCreateNestedManyWithoutUserHomeInput
    away?: MatchingUncheckedCreateNestedManyWithoutUserAwayInput
    rank?: UserTopRankingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlayerPoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayerPoolInput, UserUncheckedCreateWithoutPlayerPoolInput>
  }

  export type PlayerCreateWithoutPlayerPoolInput = {
    name: string
    speed: number
    passing: number
    dribbling: number
    heading: number
    shooting: number
    tackling: number
    marking: number
    strength: number
    weight: number
    nationality: string
  }

  export type PlayerUncheckedCreateWithoutPlayerPoolInput = {
    id?: number
    name: string
    speed: number
    passing: number
    dribbling: number
    heading: number
    shooting: number
    tackling: number
    marking: number
    strength: number
    weight: number
    nationality: string
  }

  export type PlayerCreateOrConnectWithoutPlayerPoolInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPlayerPoolInput, PlayerUncheckedCreateWithoutPlayerPoolInput>
  }

  export type SquardCreateWithoutPlayerPoolInput = {
    user: UserCreateNestedOneWithoutSquardInput
  }

  export type SquardUncheckedCreateWithoutPlayerPoolInput = {
    id?: number
    userId: number
  }

  export type SquardCreateOrConnectWithoutPlayerPoolInput = {
    where: SquardWhereUniqueInput
    create: XOR<SquardCreateWithoutPlayerPoolInput, SquardUncheckedCreateWithoutPlayerPoolInput>
  }

  export type UserUpsertWithoutPlayerPoolInput = {
    update: XOR<UserUpdateWithoutPlayerPoolInput, UserUncheckedUpdateWithoutPlayerPoolInput>
    create: XOR<UserCreateWithoutPlayerPoolInput, UserUncheckedCreateWithoutPlayerPoolInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayerPoolInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayerPoolInput, UserUncheckedUpdateWithoutPlayerPoolInput>
  }

  export type UserUpdateWithoutPlayerPoolInput = {
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    squard?: SquardUpdateManyWithoutUserNestedInput
    home?: MatchingUpdateManyWithoutUserHomeNestedInput
    away?: MatchingUpdateManyWithoutUserAwayNestedInput
    rank?: UserTopRankingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayerPoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    squard?: SquardUncheckedUpdateManyWithoutUserNestedInput
    home?: MatchingUncheckedUpdateManyWithoutUserHomeNestedInput
    away?: MatchingUncheckedUpdateManyWithoutUserAwayNestedInput
    rank?: UserTopRankingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PlayerUpsertWithoutPlayerPoolInput = {
    update: XOR<PlayerUpdateWithoutPlayerPoolInput, PlayerUncheckedUpdateWithoutPlayerPoolInput>
    create: XOR<PlayerCreateWithoutPlayerPoolInput, PlayerUncheckedCreateWithoutPlayerPoolInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutPlayerPoolInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutPlayerPoolInput, PlayerUncheckedUpdateWithoutPlayerPoolInput>
  }

  export type PlayerUpdateWithoutPlayerPoolInput = {
    name?: StringFieldUpdateOperationsInput | string
    speed?: IntFieldUpdateOperationsInput | number
    passing?: IntFieldUpdateOperationsInput | number
    dribbling?: IntFieldUpdateOperationsInput | number
    heading?: IntFieldUpdateOperationsInput | number
    shooting?: IntFieldUpdateOperationsInput | number
    tackling?: IntFieldUpdateOperationsInput | number
    marking?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerUncheckedUpdateWithoutPlayerPoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    speed?: IntFieldUpdateOperationsInput | number
    passing?: IntFieldUpdateOperationsInput | number
    dribbling?: IntFieldUpdateOperationsInput | number
    heading?: IntFieldUpdateOperationsInput | number
    shooting?: IntFieldUpdateOperationsInput | number
    tackling?: IntFieldUpdateOperationsInput | number
    marking?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
  }

  export type SquardUpsertWithoutPlayerPoolInput = {
    update: XOR<SquardUpdateWithoutPlayerPoolInput, SquardUncheckedUpdateWithoutPlayerPoolInput>
    create: XOR<SquardCreateWithoutPlayerPoolInput, SquardUncheckedCreateWithoutPlayerPoolInput>
    where?: SquardWhereInput
  }

  export type SquardUpdateToOneWithWhereWithoutPlayerPoolInput = {
    where?: SquardWhereInput
    data: XOR<SquardUpdateWithoutPlayerPoolInput, SquardUncheckedUpdateWithoutPlayerPoolInput>
  }

  export type SquardUpdateWithoutPlayerPoolInput = {
    user?: UserUpdateOneRequiredWithoutSquardNestedInput
  }

  export type SquardUncheckedUpdateWithoutPlayerPoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerPoolCreateWithoutSquardInput = {
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
    user: UserCreateNestedOneWithoutPlayerPoolInput
    playerIndex: PlayerCreateNestedOneWithoutPlayerPoolInput
  }

  export type PlayerPoolUncheckedCreateWithoutSquardInput = {
    id?: number
    userId: number
    playerId: number
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
  }

  export type PlayerPoolCreateOrConnectWithoutSquardInput = {
    where: PlayerPoolWhereUniqueInput
    create: XOR<PlayerPoolCreateWithoutSquardInput, PlayerPoolUncheckedCreateWithoutSquardInput>
  }

  export type UserCreateWithoutSquardInput = {
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    playerPool?: PlayerPoolCreateNestedManyWithoutUserInput
    home?: MatchingCreateNestedManyWithoutUserHomeInput
    away?: MatchingCreateNestedManyWithoutUserAwayInput
    rank?: UserTopRankingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSquardInput = {
    id?: number
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    playerPool?: PlayerPoolUncheckedCreateNestedManyWithoutUserInput
    home?: MatchingUncheckedCreateNestedManyWithoutUserHomeInput
    away?: MatchingUncheckedCreateNestedManyWithoutUserAwayInput
    rank?: UserTopRankingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSquardInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSquardInput, UserUncheckedCreateWithoutSquardInput>
  }

  export type PlayerPoolUpsertWithoutSquardInput = {
    update: XOR<PlayerPoolUpdateWithoutSquardInput, PlayerPoolUncheckedUpdateWithoutSquardInput>
    create: XOR<PlayerPoolCreateWithoutSquardInput, PlayerPoolUncheckedCreateWithoutSquardInput>
    where?: PlayerPoolWhereInput
  }

  export type PlayerPoolUpdateToOneWithWhereWithoutSquardInput = {
    where?: PlayerPoolWhereInput
    data: XOR<PlayerPoolUpdateWithoutSquardInput, PlayerPoolUncheckedUpdateWithoutSquardInput>
  }

  export type PlayerPoolUpdateWithoutSquardInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutPlayerPoolNestedInput
    playerIndex?: PlayerUpdateOneRequiredWithoutPlayerPoolNestedInput
  }

  export type PlayerPoolUncheckedUpdateWithoutSquardInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutSquardInput = {
    update: XOR<UserUpdateWithoutSquardInput, UserUncheckedUpdateWithoutSquardInput>
    create: XOR<UserCreateWithoutSquardInput, UserUncheckedCreateWithoutSquardInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSquardInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSquardInput, UserUncheckedUpdateWithoutSquardInput>
  }

  export type UserUpdateWithoutSquardInput = {
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    playerPool?: PlayerPoolUpdateManyWithoutUserNestedInput
    home?: MatchingUpdateManyWithoutUserHomeNestedInput
    away?: MatchingUpdateManyWithoutUserAwayNestedInput
    rank?: UserTopRankingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSquardInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    playerPool?: PlayerPoolUncheckedUpdateManyWithoutUserNestedInput
    home?: MatchingUncheckedUpdateManyWithoutUserHomeNestedInput
    away?: MatchingUncheckedUpdateManyWithoutUserAwayNestedInput
    rank?: UserTopRankingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutHomeInput = {
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    playerPool?: PlayerPoolCreateNestedManyWithoutUserInput
    squard?: SquardCreateNestedManyWithoutUserInput
    away?: MatchingCreateNestedManyWithoutUserAwayInput
    rank?: UserTopRankingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHomeInput = {
    id?: number
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    playerPool?: PlayerPoolUncheckedCreateNestedManyWithoutUserInput
    squard?: SquardUncheckedCreateNestedManyWithoutUserInput
    away?: MatchingUncheckedCreateNestedManyWithoutUserAwayInput
    rank?: UserTopRankingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHomeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHomeInput, UserUncheckedCreateWithoutHomeInput>
  }

  export type UserCreateWithoutAwayInput = {
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    playerPool?: PlayerPoolCreateNestedManyWithoutUserInput
    squard?: SquardCreateNestedManyWithoutUserInput
    home?: MatchingCreateNestedManyWithoutUserHomeInput
    rank?: UserTopRankingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAwayInput = {
    id?: number
    accountName: string
    password: string
    createdAt?: Date | string
    cash: number
    mmr?: number
    playerPool?: PlayerPoolUncheckedCreateNestedManyWithoutUserInput
    squard?: SquardUncheckedCreateNestedManyWithoutUserInput
    home?: MatchingUncheckedCreateNestedManyWithoutUserHomeInput
    rank?: UserTopRankingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAwayInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAwayInput, UserUncheckedCreateWithoutAwayInput>
  }

  export type UserUpsertWithoutHomeInput = {
    update: XOR<UserUpdateWithoutHomeInput, UserUncheckedUpdateWithoutHomeInput>
    create: XOR<UserCreateWithoutHomeInput, UserUncheckedCreateWithoutHomeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHomeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHomeInput, UserUncheckedUpdateWithoutHomeInput>
  }

  export type UserUpdateWithoutHomeInput = {
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    playerPool?: PlayerPoolUpdateManyWithoutUserNestedInput
    squard?: SquardUpdateManyWithoutUserNestedInput
    away?: MatchingUpdateManyWithoutUserAwayNestedInput
    rank?: UserTopRankingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHomeInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    playerPool?: PlayerPoolUncheckedUpdateManyWithoutUserNestedInput
    squard?: SquardUncheckedUpdateManyWithoutUserNestedInput
    away?: MatchingUncheckedUpdateManyWithoutUserAwayNestedInput
    rank?: UserTopRankingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutAwayInput = {
    update: XOR<UserUpdateWithoutAwayInput, UserUncheckedUpdateWithoutAwayInput>
    create: XOR<UserCreateWithoutAwayInput, UserUncheckedCreateWithoutAwayInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAwayInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAwayInput, UserUncheckedUpdateWithoutAwayInput>
  }

  export type UserUpdateWithoutAwayInput = {
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    playerPool?: PlayerPoolUpdateManyWithoutUserNestedInput
    squard?: SquardUpdateManyWithoutUserNestedInput
    home?: MatchingUpdateManyWithoutUserHomeNestedInput
    rank?: UserTopRankingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAwayInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cash?: IntFieldUpdateOperationsInput | number
    mmr?: IntFieldUpdateOperationsInput | number
    playerPool?: PlayerPoolUncheckedUpdateManyWithoutUserNestedInput
    squard?: SquardUncheckedUpdateManyWithoutUserNestedInput
    home?: MatchingUncheckedUpdateManyWithoutUserHomeNestedInput
    rank?: UserTopRankingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PlayerPoolCreateManyUserInput = {
    id?: number
    playerId: number
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
  }

  export type SquardCreateManyUserInput = {
    id?: number
    playerPoolId: number
  }

  export type MatchingCreateManyUserHomeInput = {
    id?: number
    userAwayId: number
    result: string
  }

  export type MatchingCreateManyUserAwayInput = {
    id?: number
    userHomeId: number
    result: string
  }

  export type PlayerPoolUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
    playerIndex?: PlayerUpdateOneRequiredWithoutPlayerPoolNestedInput
    squard?: SquardUpdateOneWithoutPlayerPoolNestedInput
  }

  export type PlayerPoolUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
    squard?: SquardUncheckedUpdateOneWithoutPlayerPoolNestedInput
  }

  export type PlayerPoolUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
  }

  export type SquardUpdateWithoutUserInput = {
    playerPool?: PlayerPoolUpdateOneRequiredWithoutSquardNestedInput
  }

  export type SquardUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerPoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SquardUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerPoolId?: IntFieldUpdateOperationsInput | number
  }

  export type MatchingUpdateWithoutUserHomeInput = {
    result?: StringFieldUpdateOperationsInput | string
    userAway?: UserUpdateOneRequiredWithoutAwayNestedInput
  }

  export type MatchingUncheckedUpdateWithoutUserHomeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userAwayId?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
  }

  export type MatchingUncheckedUpdateManyWithoutUserHomeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userAwayId?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
  }

  export type MatchingUpdateWithoutUserAwayInput = {
    result?: StringFieldUpdateOperationsInput | string
    userHome?: UserUpdateOneRequiredWithoutHomeNestedInput
  }

  export type MatchingUncheckedUpdateWithoutUserAwayInput = {
    id?: IntFieldUpdateOperationsInput | number
    userHomeId?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
  }

  export type MatchingUncheckedUpdateManyWithoutUserAwayInput = {
    id?: IntFieldUpdateOperationsInput | number
    userHomeId?: IntFieldUpdateOperationsInput | number
    result?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerPoolCreateManyPlayerIndexInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    playerLevel: number
    playerName: string
    count: number
    sidelined?: boolean
    stamina?: number
  }

  export type PlayerPoolUpdateWithoutPlayerIndexInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutPlayerPoolNestedInput
    squard?: SquardUpdateOneWithoutPlayerPoolNestedInput
  }

  export type PlayerPoolUncheckedUpdateWithoutPlayerIndexInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
    squard?: SquardUncheckedUpdateOneWithoutPlayerPoolNestedInput
  }

  export type PlayerPoolUncheckedUpdateManyWithoutPlayerIndexInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerLevel?: IntFieldUpdateOperationsInput | number
    playerName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    sidelined?: BoolFieldUpdateOperationsInput | boolean
    stamina?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerCountOutputTypeDefaultArgs instead
     */
    export type PlayerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserTopRankingsDefaultArgs instead
     */
    export type UserTopRankingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserTopRankingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerDefaultArgs instead
     */
    export type PlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerPoolDefaultArgs instead
     */
    export type PlayerPoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerPoolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SquardDefaultArgs instead
     */
    export type SquardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SquardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchingDefaultArgs instead
     */
    export type MatchingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchingDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}